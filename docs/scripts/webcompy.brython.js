__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1652032582653, "webcompy": [".py", "from . import (\nbrython,\naio,\najax,\napp,\ncomponents,\nelements,\nexception,\nreactive,\nrouter,\nutils,\n)\n\nif brython.browser:\n cli=None\nelse :\n from . import cli\n \n \n__all__=[\n\"brython\",\n\"app\",\n\"reactive\",\n\"elements\",\n\"components\",\n\"router\",\n\"exception\",\n\"aio\",\n\"ajax\",\n\"utils\",\n\"cli\",\n]\n", ["webcompy"], 1], "webcompy.__main__": [".py", "from webcompy.cli._argparser import get_params\nfrom webcompy.cli._server import run_server\nfrom webcompy.cli._generate import generate_static_site\nfrom webcompy.cli._init_project import init_project\n\n\ndef main():\n command,_=get_params()\n if command ==\"start\":\n  run_server()\n elif command ==\"generate\":\n  generate_static_site()\n elif command ==\"init\":\n  init_project()\n  \n  \nif __name__ ==\"__main__\":\n main()\n", ["webcompy.cli._argparser", "webcompy.cli._generate", "webcompy.cli._init_project", "webcompy.cli._server"]], "webcompy.aio._aio": [".py", "from typing import Any,Callable,Coroutine,Generic,ParamSpec,TypeVar\nfrom webcompy.brython import browser\nfrom webcompy.reactive._base import ReactiveBase\n\nif browser:\n aio_run:Any=browser.aio.run\nelse :\n import asyncio\n \n aio_run:Any=asyncio.run\n \n \nA=ParamSpec(\"A\")\nT=TypeVar(\"T\")\n\n\n\ndef resolve_async(\ncoroutine:Coroutine[Any,Any,T],\non_done:Callable[[T],None ]|None =None ,\non_error:Callable[[Exception],None ]|None =None ,\n):\n async def resolve(\n coroutine:Coroutine[Any,Any,T],\n resolver:Callable[[T],None ]|None ,\n error:Callable[[Exception],None ]|None ,\n )->None :\n  try :\n   ret=await coroutine\n   if resolver is not None :\n    resolver(ret)\n  except Exception as err:\n   if error is not None :\n    error(err)\n    \n aio_run(resolve(coroutine,on_done,on_error))\n \n \nclass AsyncWrapper(Generic[T]):\n def __init__(\n self,\n resolver:Callable[[T],None ]=lambda _:None ,\n error:Callable[[Exception],None ]=lambda _:None ,\n )->None :\n  self.resolver=resolver\n  self.error=error\n  \n def __call__(self,async_callable:Callable[A,Coroutine[Any,Any,T]]):\n  def inner(*args:A.args,**kwargs:A.kwargs)->None :\n   resolve_async(async_callable(*args,**kwargs),self.resolver,self.error)\n   \n  return inner\n  \n  \nclass AsyncComputed(ReactiveBase[T |None ]):\n _done:bool\n _exception:Exception |None\n \n def __init__(\n self,\n coroutine:Coroutine[Any,Any,T],\n )->None :\n  super().__init__(None )\n  self._done=False\n  self._exception=None\n  resolve_async(coroutine,self._resolver,self._error)\n  \n @ReactiveBase._change_event\n def _resolver(self,res:T):\n  self._done=True\n  self._value=res\n  \n @ReactiveBase._change_event\n def _error(self,err:Exception):\n  self._done=False\n  self._exception=err\n  \n @property\n @ReactiveBase._get_evnet\n def value(self)->T |None :\n  return self._value\n  \n @property\n @ReactiveBase._get_evnet\n def error(self)->Exception |None :\n  return self._exception\n  \n @property\n @ReactiveBase._get_evnet\n def done(self)->bool:\n  return self._done\n", ["asyncio", "typing", "webcompy.brython", "webcompy.reactive._base"]], "webcompy.aio._utils": [".py", "from webcompy.brython import browser\n\n\nasync def sleep(delay:float)->None :\n ''\n\n\n\n \n if browser:\n  await browser.aio.sleep(delay)\n", ["webcompy.brython"]], "webcompy.aio": [".py", "from webcompy.aio._aio import AsyncComputed,AsyncWrapper,resolve_async\nfrom webcompy.aio._utils import sleep\n\n__all__=[\"AsyncComputed\",\"AsyncWrapper\",\"resolve_async\",\"sleep\"]\n", ["webcompy.aio._aio", "webcompy.aio._utils"], 1], "webcompy.ajax._fetch": [".py", "from json import loads as json_loads,dumps as json_dumps\nfrom typing import Any,Dict,Literal,Union\nimport urllib.parse\nfrom webcompy.elements.types._refference import DomNodeRef\nfrom webcompy.exception import WebComPyException\nfrom webcompy.brython import browser\n\n\n\nclass WebComPyHttpClientException(WebComPyException):\n pass\n \n \nclass Response:\n _text:str\n _headers:dict[str,str]\n _status_code:int\n _reason:str\n _ok:bool\n \n def __init__(\n self,\n text:str,\n headers:dict[str,str],\n status_code:int,\n reason:str,\n ok:bool,\n )->None :\n  self._text=text\n  self._headers=headers\n  self._status_code=status_code\n  self._reason=reason\n  self._ok=ok\n  \n def __repr__(self)->str:\n  return (\n  \"Response(\"\n  +\", \".join(\n  n+\"=\"+(f\"'{v}'\"if isinstance(v,str)else str(v))\n  for n,v in sorted(\n  map(\n  lambda name:(name[1:],getattr(self,name)),\n  filter(\n  lambda name:name.startswith(\"_\"),\n  self.__annotations__.keys(),\n  ),\n  ),\n  key=lambda li:li[0],\n  )\n  )\n  +\")\"\n  )\n  \n def raise_for_status(self):\n  if not self._ok:\n   raise WebComPyHttpClientException\n   \n def json(self,**kwargs:Any)->dict[str,Any]:\n  return json_loads(self._text,**kwargs)\n  \n @property\n def text(self):\n  return self._text\n  \n @property\n def headers(self):\n  return self._headers\n  \n @property\n def status_code(self):\n  return self._status_code\n  \n @property\n def ok(self):\n  return self._ok\n  \n  \nclass HttpClient:\n @classmethod\n async def request(\n cls,\n method:Literal[\"GET\",\"OPTIONS\",\"HEAD\",\"POST\",\"PUT\",\"PATCH\",\"DELETE\"],\n url:str,\n headers:Union[Dict[str,str],None ]=None ,\n query_params:Union[Dict[str,str],None ]=None ,\n json:Union[Dict[str,Any],None ]=None ,\n body_data:Union[str,bytes,None ]=None ,\n form_data:Union[Dict[str,Union[str,bytes]],None ]=None ,\n form_element:Union[DomNodeRef,None ]=None ,\n )->Response:\n  if browser:\n  \n   if query_params is not None :\n    send_url=url+\"?\"+urllib.parse.urlencode(query_params)\n   else :\n    send_url=url\n    \n   req_headers=dict(\n   tuple(map(urllib.parse.quote,map(str,it)))\n   for it in (headers if headers else {}).items()\n   )\n   \n   has_body=any(\n   (\n   json is not None ,\n   body_data is not None ,\n   form_data is not None ,\n   form_element is not None ,\n   )\n   )\n   if has_body:\n    if json is not None :\n     req_headers[\"Content-Type\"]=\"application/json\"\n     body=json_dumps(json,ensure_ascii=True )\n    elif body_data is not None :\n     body=body_data\n    elif form_data is not None :\n     body=browser.window.FormData.new()\n     for key,value in form_data.items():\n      body.set(key,value)\n    elif form_element is not None :\n     body=browser.window.FormData.new(form_element.node)\n    else :\n     body=browser.javascript.UNDEFINED\n    options={\"method\":method,\"headers\":req_headers,\"body\":body}\n   else :\n    options={\"method\":method,\"headers\":req_headers}\n   try :\n    res=await browser.window.fetch(send_url,options)\n   except Exception as err:\n    raise WebComPyHttpClientException(str(err))\n   else :\n    return Response(\n    text=(await res.text()),\n    headers=dict(zip(res.headers.keys(),res.headers.values())),\n    status_code=res.status,\n    reason=res.statusText,\n    ok=res.ok,\n    )\n  else :\n   raise WebComPyHttpClientException\n   \n @classmethod\n async def get(\n cls,\n url:str,\n query_params:Union[Dict[str,str],None ]=None ,\n headers:Union[Dict[str,str],None ]=None ,\n )->Response:\n  if browser:\n   res=await HttpClient.request(\n   \"GET\",url,headers=headers,query_params=query_params\n   )\n   return res\n  else :\n   raise WebComPyHttpClientException\n   \n @classmethod\n async def head(\n cls,\n url:str,\n query_params:Union[Dict[str,str],None ]=None ,\n headers:Union[Dict[str,str],None ]=None ,\n )->Response:\n  if browser:\n   res=await HttpClient.request(\n   \"HEAD\",url,headers=headers,query_params=query_params\n   )\n   return res\n  else :\n   raise WebComPyHttpClientException\n   \n @classmethod\n async def options(\n cls,\n url:str,\n query_params:Union[Dict[str,str],None ]=None ,\n headers:Union[Dict[str,str],None ]=None ,\n )->Response:\n  if browser:\n   res=await HttpClient.request(\n   \"OPTIONS\",url,headers=headers,query_params=query_params\n   )\n   return res\n  else :\n   raise WebComPyHttpClientException\n   \n @classmethod\n async def post(\n cls,\n url:str,\n headers:Union[Dict[str,str],None ]=None ,\n query_params:Union[Dict[str,str],None ]=None ,\n json:Union[Dict[str,Any],None ]=None ,\n body_data:Union[str,bytes,None ]=None ,\n form_data:Union[Dict[str,Union[str,bytes]],None ]=None ,\n form_element:Union[DomNodeRef,None ]=None ,\n )->Response:\n  if browser:\n   res=await HttpClient.request(\n   \"POST\",\n   url,\n   headers=headers,\n   query_params=query_params,\n   json=json,\n   body_data=body_data,\n   form_data=form_data,\n   form_element=form_element,\n   )\n   return res\n  else :\n   raise WebComPyHttpClientException\n   \n @classmethod\n async def put(\n cls,\n url:str,\n headers:Union[Dict[str,str],None ]=None ,\n query_params:Union[Dict[str,str],None ]=None ,\n json:Union[Dict[str,Any],None ]=None ,\n body_data:Union[str,bytes,None ]=None ,\n form_data:Union[Dict[str,Union[str,bytes]],None ]=None ,\n form_element:Union[DomNodeRef,None ]=None ,\n )->Response:\n  if browser:\n   res=await HttpClient.request(\n   \"PUT\",\n   url,\n   headers=headers,\n   query_params=query_params,\n   json=json,\n   body_data=body_data,\n   form_data=form_data,\n   form_element=form_element,\n   )\n   return res\n  else :\n   raise WebComPyHttpClientException\n   \n @classmethod\n async def delete(\n cls,\n url:str,\n headers:Union[Dict[str,str],None ]=None ,\n query_params:Union[Dict[str,str],None ]=None ,\n json:Union[Dict[str,Any],None ]=None ,\n body_data:Union[str,bytes,None ]=None ,\n form_data:Union[Dict[str,Union[str,bytes]],None ]=None ,\n form_element:Union[DomNodeRef,None ]=None ,\n )->Response:\n  if browser:\n   res=await HttpClient.request(\n   \"DELETE\",\n   url,\n   headers=headers,\n   query_params=query_params,\n   json=json,\n   body_data=body_data,\n   form_data=form_data,\n   form_element=form_element,\n   )\n   return res\n  else :\n   raise WebComPyHttpClientException\n   \n @classmethod\n async def patch(\n cls,\n url:str,\n headers:Union[Dict[str,str],None ]=None ,\n query_params:Union[Dict[str,str],None ]=None ,\n json:Union[Dict[str,Any],None ]=None ,\n body_data:Union[str,bytes,None ]=None ,\n form_data:Union[Dict[str,Union[str,bytes]],None ]=None ,\n form_element:Union[DomNodeRef,None ]=None ,\n )->Response:\n  if browser:\n   res=await HttpClient.request(\n   \"PATCH\",\n   url,\n   headers=headers,\n   query_params=query_params,\n   json=json,\n   body_data=body_data,\n   form_data=form_data,\n   form_element=form_element,\n   )\n   return res\n  else :\n   raise WebComPyHttpClientException\n", ["json", "typing", "urllib.parse", "webcompy.brython", "webcompy.elements.types._refference", "webcompy.exception"]], "webcompy.ajax": [".py", "from webcompy.ajax._fetch import HttpClient,Response,WebComPyHttpClientException\n\n__all__=[\n\"HttpClient\",\n\"Response\",\n\"WebComPyHttpClientException\",\n]\n", ["webcompy.ajax._fetch"], 1], "webcompy.app._app": [".py", "from typing import Dict,List,Optional,Tuple,TypedDict\nfrom webcompy.components import ComponentGenerator\nfrom webcompy.router import Router\nfrom webcompy.app._root_component import AppDocumentRoot\n\n\nclass Head(TypedDict,total=False ):\n title:str\n meta:List[Dict[str,str]]\n link:List[Dict[str,str]]\n script:List[Tuple[Dict[str,str],Optional[str]]]\n \n \nclass WebComPyApp:\n _root:AppDocumentRoot\n _head:Head\n _scripts:List[Tuple[Dict[str,str],Optional[str]]]\n \n def __init__(\n self,\n *,\n root_component:ComponentGenerator[None ],\n router:Router |None =None ,\n )->None :\n  self._head:Head={\"meta\":[],\"link\":[],\"script\":[]}\n  self._scripts=[]\n  self._root=AppDocumentRoot(root_component,router)\n  \n def set_title(self,title:str):\n  self._head[\"title\"]=title\n  \n def append_meta(self,attributes:Dict[str,str]):\n  if \"meta\"in self._head:\n   self._head[\"meta\"].append(attributes)\n  else :\n   self._head[\"meta\"]=[attributes]\n   \n def append_link(self,attributes:Dict[str,str]):\n  if \"link\"in self._head:\n   self._head[\"link\"].append(attributes)\n  else :\n   self._head[\"link\"]=[attributes]\n   \n def append_script(\n self,\n attributes:Dict[str,str],\n script:str |None =None ,\n in_head:bool=False ,\n ):\n  if not in_head:\n   self._scripts.append((attributes,script))\n  elif \"script\"in self._head:\n   self._head[\"script\"].append((attributes,script))\n  else :\n   self._head[\"script\"]=[(attributes,script)]\n   \n def set_head(self,head:Head):\n  self._head=head\n  \n def update_head(self,head:Head):\n  if \"title\"in head:\n   self.set_title(head[\"title\"])\n  for meta in head.get(\"meta\",[]):\n   self.append_meta(meta)\n  for link in head.get(\"link\",[]):\n   self.append_link(link)\n  for attrs,script in head.get(\"script\",[]):\n   self.append_script(attrs,script,True )\n   \n @property\n def __component__(self):\n  return self._root\n  \n @property\n def __head__(self):\n  return self._head\n  \n @property\n def __scripts__(self):\n  return self._scripts\n", ["typing", "webcompy.app._root_component", "webcompy.components", "webcompy.router"]], "webcompy.app._root_component": [".py", "from webcompy.elements import html\nfrom webcompy.brython import DOMNode,browser\nfrom webcompy.components._abstract import NonPropsComponentBase\nfrom webcompy.components._component import Component\nfrom webcompy.components._generator import ComponentGenerator,ComponentStore\nfrom webcompy.components._decorators import component_template\nfrom webcompy.router._router import Router\nfrom webcompy.router._view import RouterView\nfrom webcompy.router._link import TypedRouterLink\nfrom webcompy.exception import WebComPyException\n\n\nclass AppRootComponent(NonPropsComponentBase):\n @component_template\n def template(self):\n  return html.DIV({\"id\":\"webcompy-app\"},self.context.slots(\"root\"))\n  \n  \nclass AppDocumentRoot(Component):\n _router:Router |None\n __loading:bool\n \n def __init__(\n self,root_component:ComponentGenerator[None ],router:Router |None\n )->None :\n  self.__loading=True\n  self._router=router\n  if self._router:\n   RouterView.__set_router__(self._router)\n   TypedRouterLink.__set_router__(self._router)\n  super().__init__(AppRootComponent,None ,{\"root\":lambda :root_component(None )})\n  \n @property\n def render(self):\n  return self._render\n  \n def _render(self):\n  if browser and self.__loading:\n   self.__loading=False\n   browser.document.getElementById(\"webcompy-loading\").remove()\n  self._property[\"on_before_rendering\"]()\n  for child in self._children:\n   child._render()\n  self._property[\"on_after_rendering\"]()\n  \n def _init_node(self)->DOMNode:\n  if browser:\n   node=browser.document.getElementById(\"webcompy-app\")\n   for name in tuple(node.attrs.keys()):\n    if name !=\"id\":\n     del node.attrs[name]\n   node.__webcompy_node__=True\n   return node\n  else :\n   raise WebComPyException(\"Not in Browser environment.\")\n   \n def _mount_node(self):\n  pass\n  \n def _get_belonging_component(self):\n  return \"\"\n  \n def _get_belonging_components(self)->tuple[\"Component\",...]:\n  return (self,)\n  \n @property\n def routes(self):\n  return self._router.__routes__ if self._router else None\n  \n @property\n def router_mode(self):\n  return self._router.__mode__ if self._router else None\n  \n def set_path(self,path:str):\n  if self._router:\n   self._router.__set_path__(path,None )\n  else :\n   return None\n   \n @property\n def style(self):\n  return \"\\n\".join(\n  style\n  for component in ComponentStore.components.values()\n  if (style :=component.scoped_style)\n  )\n  \n def _render_html(\n self,newline:bool=False ,indent:int=2,count:int=0\n )->str:\n  hidden=self._attrs.get(\"hidden\")\n  self._attrs[\"hidden\"]=True\n  html=super()._render_html(newline,indent,count)\n  if hidden is None :\n   del self._attrs[\"hidden\"]\n  else :\n   self._attrs[\"hidden\"]=hidden\n  return html\n", ["webcompy.brython", "webcompy.components._abstract", "webcompy.components._component", "webcompy.components._decorators", "webcompy.components._generator", "webcompy.elements", "webcompy.exception", "webcompy.router._link", "webcompy.router._router", "webcompy.router._view"]], "webcompy.app": [".py", "from webcompy.app._app import WebComPyApp\n\n__all__=[\n\"WebComPyApp\",\n]\n", ["webcompy.app._app"], 1], "webcompy.brython._modules": [".py", "from webcompy.brython._typing import _browser\n\nbrowser=_browser if _browser.ENVIRONMENT ==\"browser\"else None\n", ["webcompy.brython._typing"]], "webcompy.brython": [".py", "from webcompy.brython._modules import browser\nfrom webcompy.brython._typing._dom_objs import DOMNode,DOMEvent\n\n__all__=[\"browser\",\"DOMNode\",\"DOMEvent\"]\n", ["webcompy.brython._modules", "webcompy.brython._typing._dom_objs"], 1], "webcompy.brython._typing._browser": [".py", "from typing import Final,Literal\n\n\nENVIRONMENT:Final[Literal[\"browser\",\"server\"]]\n\n\ntry :\n from browser import *\n from browser import (\n aio,\n local_storage,\n markdown,\n object_storage,\n session_storage,\n svg,\n timer,\n websocket,\n worker,\n )\n import javascript\n \n ENVIRONMENT=\"browser\"\nexcept ModuleNotFoundError:\n ENVIRONMENT=\"server\"\n", ["browser", "javascript", "typing"]], "webcompy.brython._typing._dom_objs": [".py", "try :\n from browser import DOMNode,DOMEvent\nexcept ModuleNotFoundError:\n from webcompy.exception import WebComPyException\n \n def raise_exception(name:str):\n  raise WebComPyException(\n  f\"{name} object can be accessed only in browser environment.\"\n  )\n  \n class DOMNode:\n  def __init__(self,*args,**kwargs)->None :\n   raise_exception(\"DOMNode\")\n   \n  @classmethod\n  def __getattr__(cls,_):\n   raise_exception(\"DOMNode\")\n   \n class DOMEvent:\n  def __init__(self,*args,**kwargs)->None :\n   raise_exception(\"DOMEvent\")\n   \n  @classmethod\n  def __getattr__(cls,_):\n   raise_exception(\"DOMEvent\")\n", ["browser", "webcompy.exception"]], "webcompy.brython._typing": [".py", "", [], 1], "webcompy.cli._argparser": [".py", "from argparse import ArgumentParser\nimport sys\nfrom typing import Any,Literal\n\n\ndef get_params()->tuple[Literal[\"start\",\"generate\",\"init\"],dict[str,Any]]:\n def _command(subcommand_name:str):\n  return lambda :subcommand_name\n  \n maincommand=\"python -m webcompy\"\n parser=ArgumentParser(prog=maincommand,add_help=True )\n subparsers=parser.add_subparsers()\n \n \n subcommand_name=\"start\"\n parser_start=subparsers.add_parser(\n subcommand_name,\n help=f\"Starts HTTP server. See `{maincommand} {subcommand_name} --help` for options.\",\n )\n parser_start.add_argument(\n \"--dev\",\n action=\"store_true\",\n help=\"launch dev server with hot-reload\",\n )\n parser_start.add_argument(\n \"--port\",\n type=int,\n help=\"server port\",\n )\n parser_start.set_defaults(__command_getter__=_command(subcommand_name))\n \n \n subcommand_name=\"generate\"\n parser_generate=subparsers.add_parser(\n subcommand_name,\n help=f\"Generates static html files. See `{maincommand} {subcommand_name} --help` for options.\",\n )\n parser_generate.add_argument(\n \"--dist\",\n type=str,\n help=\"dist dir\",\n )\n parser_generate.set_defaults(__command_getter__=_command(subcommand_name))\n \n \n subcommand_name=\"init\"\n parser_init=subparsers.add_parser(\n subcommand_name,\n help=\"Creates new project on current dir.\",\n )\n parser_init.set_defaults(__command_getter__=_command(subcommand_name))\n \n \n args=parser.parse_args()\n if hasattr(args,\"__command_getter__\"):\n  subcommand_name=getattr(args,\"__command_getter__\")()\n  args_dict={n:getattr(args,n)for n in dir(args)if not n.startswith(\"_\")}\n  return subcommand_name,args_dict\n else :\n  parser.print_help()\n  sys.exit()\n", ["argparse", "sys", "typing"]], "webcompy.cli._asgi_app": [".py", "from webcompy.cli._server import create_asgi_app\nfrom webcompy.cli._utils import get_config\nfrom webcompy.cli._argparser import get_params\n\nconfig=get_config()\n_,args=get_params()\napp=create_asgi_app(config,args[\"dev\"])\n", ["webcompy.cli._argparser", "webcompy.cli._server", "webcompy.cli._utils"]], "webcompy.cli._brython_cli": [".py", "import os\nimport pathlib\nimport shutil\nimport sys\nfrom tempfile import TemporaryDirectory\nfrom brython.__main__ import main as brython_main\nfrom webcompy.cli._utils import external_cli_tool_wrapper\nfrom webcompy.cli._exception import WebComPyCliException\n\n\n@external_cli_tool_wrapper\ndef install_brython_scripts(dest:str):\n DEST_FILES={\"brython.js\",\"brython_stdlib.js\",\"unicode.txt\"}\n dest_path=pathlib.Path(dest).absolute()\n if not dest_path.exists():\n  os.mkdir(dest_path)\n else :\n  for p in (dest_path /n for n in DEST_FILES):\n   if p.exists():\n    os.remove(p)\n    \n with TemporaryDirectory()as temp_dir:\n  temp_dir=pathlib.Path(temp_dir)\n  os.chdir(temp_dir)\n  sys.argv.append(\"--install\")\n  brython_main()\n  for child in temp_dir.iterdir():\n   if child.name.lower()in DEST_FILES:\n    shutil.copy(child,dest_path)\n  os.chdir(temp_dir.parent)\n  \n  \n@external_cli_tool_wrapper\ndef make_brython_package(package_dir:str,dest:str):\n if not (package_dir_path :=pathlib.Path(package_dir).absolute()).exists():\n  raise WebComPyCliException(f\"Package dir '{package_dir}' does not exist\")\n if not (dest_path :=pathlib.Path(dest).absolute()).exists():\n  os.mkdir(dest_path)\n package_name=package_dir_path.name\n package_file_name=f\"{package_name}.brython.js\"\n os.chdir(package_dir_path)\n sys.argv.append(\"--make_package\")\n sys.argv.append(package_name)\n brython_main()\n if (dest_path /package_file_name).exists():\n  os.remove(dest_path /package_file_name)\n shutil.move(package_dir_path /package_file_name,dest_path)\n", ["brython.__main__", "os", "pathlib", "shutil", "sys", "tempfile", "webcompy.cli._exception", "webcompy.cli._utils"]], "webcompy.cli._config": [".py", "from dataclasses import dataclass\n\n@dataclass\nclass WebComPyConfig:\n app_package:str\n base:str=\"/\"\n server_port:int=8080\n dist:str=\"dist\"\n \n def __post_init__(self):\n  self.base=f\"/{base}\"if (base :=self.base.strip(\"/\"))else \"/\"\n", ["dataclasses"]], "webcompy.cli._exception": [".py", "from webcompy.exception import WebComPyException\n\n\nclass WebComPyCliException(WebComPyException):\n pass\n", ["webcompy.exception"]], "webcompy.cli._generate": [".py", "from functools import partial\nimport os\nimport pathlib\nimport shutil\nfrom webcompy.cli._argparser import get_params\nfrom webcompy.cli._brython_cli import (\ninstall_brython_scripts,\nmake_brython_package,\n)\nfrom webcompy.cli._html import generate_html\nfrom webcompy.cli._utils import (\nget_app,\nget_config,\nget_webcompy_packge_dir,\n)\n\n\ndef generate_static_site():\n config=get_config()\n app=get_app(config)\n _,args=get_params()\n config=get_config()\n dist=config.dist if args.get(\"dist\")is None else args[\"dist\"]\n \n dist_dir=pathlib.Path(dist).absolute()\n if dist_dir.exists():\n  shutil.rmtree(dist_dir)\n os.mkdir(dist_dir)\n \n scripts_dir=dist_dir /\"scripts\"\n os.mkdir(scripts_dir)\n install_brython_scripts(\n str(scripts_dir),\n )\n make_brython_package(\n get_webcompy_packge_dir(),\n str(scripts_dir),\n )\n make_brython_package(\n str(pathlib.Path(f\"./{config.app_package}\").absolute()),\n str(scripts_dir),\n )\n \n html_generator=partial(generate_html,config,False )\n if app.__component__.router_mode ==\"history\"and app.__component__.routes:\n  for p,_,_,_,page in app.__component__.routes:\n   if path_params :=page.get(\"path_params\"):\n    paths={p.format(**params)for params in path_params}\n   else :\n    paths={p}\n   for path in paths:\n    if not (path_dir :=dist_dir /path).exists():\n     os.makedirs(path_dir)\n    app.__component__.set_path(path)\n    html=html_generator(app,True )\n    html_path=path_dir /\"index.html\"\n    html_path.open(\"w\",encoding=\"utf8\").write(html)\n    print(html_path)\n  app.__component__.set_path(\"//:404://\")\n  html=html_generator(app,True )\n  html_path=dist_dir /\"404.html\"\n  html_path.open(\"w\",encoding=\"utf8\").write(html)\n  print(html_path)\n else :\n  html=html_generator(app,False )\n  html_path=dist_dir /\"index.html\"\n  html_path.open(\"w\",encoding=\"utf8\").write(html)\n  print(html_path)\n print(\"done\")\n", ["functools", "os", "pathlib", "shutil", "webcompy.cli._argparser", "webcompy.cli._brython_cli", "webcompy.cli._html", "webcompy.cli._utils"]], "webcompy.cli._html": [".py", "from webcompy.elements.types import Element\nfrom webcompy.elements.typealias import ElementChildren\nfrom webcompy.app._app import WebComPyApp\nfrom webcompy.utils import strip_multiline_text\nfrom webcompy.cli._config import WebComPyConfig\n\n\nclass _HtmlElement(Element):\n def __init__(\n self,\n tag_name:str,\n attrs:dict[str,str],\n *children:ElementChildren,\n )->None :\n  super().__init__(\n  tag_name,\n  attrs,\n  {},\n  None ,\n  children,\n  )\n  \n def render_html(self):\n  return self._render_html(False ,0)\n  \n def _get_belonging_component(self):\n  return \"\"\n  \n def _get_belonging_components(self):\n  return tuple()\n  \n  \nclass _Loadscreen(_HtmlElement):\n def __init__(self)->None :\n  super().__init__(\n  \"div\",\n  {\"id\":\"webcompy-loading\"},\n  _HtmlElement(\n  \"style\",\n  {},\n  strip_multiline_text(\n  \"\"\"\n                    body {\n                        margin: 0;\n                        padding: 0;\n                        box-sizing: border-box;\n                        width: 100vw;\n                        height: 100vh;\n                    }\n                    .container {\n                        width: 100%;\n                        height: 100%;\n                        display: flex;\n                        flex-direction: column;\n                        align-items: center;\n                        justify-content: center;\n                        position: fixed;\n                    }\n                    .loader {\n                        border: 12px solid lightgray;\n                        border-radius: 50%;\n                        border-top: 12px solid skyblue;\n                        width: 100px;\n                        height: 100px;\n                        animation: spin 1s linear infinite;\n                    }\n                    @keyframes spin{\n                        0%{\n                            transform: rotate(0deg);\n                        }\n                        100%{\n                            transform: rotate(360deg);\n                        }\n                    }\n                    \"\"\"\n  ),\n  ),\n  _HtmlElement(\n  \"div\",\n  {\"class\":\"container\"},\n  _HtmlElement(\n  \"div\",\n  {\"class\":\"loader\"},\n  ),\n  ),\n  ),\n  \n  \ndef _load_scripts(scripts:list[tuple[dict[str,str],str |None ]]):\n return [\n _HtmlElement(\n \"script\",\n attrs,\n strip_multiline_text(script if script else \"\"),\n )\n for attrs,script in scripts\n ]\n \n \ndef generate_html(\nconfig:WebComPyConfig,\ndev_mode:bool,\napp:WebComPyApp,\nprerender:bool,\n):\n base=b if (b :=config.base)==\"/\"else f\"{b}/\"\n scripts:list[tuple[dict[str,str],str |None ]]=[\n (\n {\n \"type\":\"text/javascript\",\n \"src\":f\"{base}scripts/brython.js\",\n },\n None ,\n ),\n (\n {\n \"type\":\"text/javascript\",\n \"src\":f\"{base}scripts/brython_stdlib.js\",\n },\n None ,\n ),\n (\n {\n \"type\":\"text/javascript\",\n \"src\":f\"{base}scripts/webcompy.brython.js\",\n },\n None ,\n ),\n (\n {\n \"type\":\"text/javascript\",\n \"src\":f\"{base}scripts/{config.app_package}.brython.js\",\n },\n None ,\n ),\n ]\n scripts.extend(app.__scripts__)\n scripts.append(\n (\n {\"type\":\"text/python\"},\n \"\"\"\n                from {app_package}.bootstrap import app\n                app.__component__.render()\n            \"\"\".format(\n app_package=config.app_package\n ),\n )\n )\n if dev_mode:\n  scripts.append(\n  (\n  {\"type\":\"text/javascript\"},\n  \"\"\"\n                    var stream= new EventSource('{base}_webcompy_reload');\n                    stream.addEventListener('error', (e) => window.location.reload());\n                \"\"\".format(\n  base=base\n  ),\n  )\n  )\n if title :=app.__head__.get(\"title\"):\n  title=_HtmlElement(\"title\",{},title)\n else :\n  title=None\n if dev_mode:\n  brython_options=\"{debug: 1, cache: false, indexedDB: true}\"\n else :\n  brython_options=\"{debug: 0, cache: true, indexedDB: true}\"\n if prerender:\n  app_root=app.__component__\n else :\n  app_root=_HtmlElement(\"div\",{\"id\":\"webcompy-app\",\"hidden\":\"\"})\n return (\n \"<!doctype html>\"\n +_HtmlElement(\n \"html\",\n {},\n _HtmlElement(\n \"head\",\n {},\n title,\n *[\n _HtmlElement(\"meta\",attrs)\n for attrs in app.__head__.get(\"meta\",[])\n ],\n _HtmlElement(\"base\",{\"href\":base}),\n _HtmlElement(\"style\",{},\"*[hidden] { display: none; }\"),\n _HtmlElement(\"style\",{},*app.__component__.style.split(\"\\n\")),\n *[\n _HtmlElement(\"link\",attrs)\n for attrs in app.__head__.get(\"link\",[])\n ],\n *_load_scripts(app.__head__.get(\"script\",[])),\n ),\n _HtmlElement(\n \"body\",\n {\"onload\":f\"brython({brython_options})\"},\n _Loadscreen(),\n app_root,\n *_load_scripts(scripts),\n ),\n ).render_html()\n )\n", ["webcompy.app._app", "webcompy.cli._config", "webcompy.elements.typealias", "webcompy.elements.types", "webcompy.utils"]], "webcompy.cli._init_project": [".py", "import os\nimport pathlib\nimport shutil\nimport sys\nfrom webcompy.cli._utils import get_webcompy_packge_dir\n\n\ndef _get_files(path:pathlib.Path,suffix:str)->list[str]:\n ret:list[str]=[]\n if path.is_dir():\n  for p in path.iterdir():\n   ret.extend(_get_files(p,suffix))\n elif path.suffix ==suffix:\n  ret.append(str(path))\n return ret\n \n \ndef init_project():\n template_data_dir=(\n pathlib.Path(get_webcompy_packge_dir())/\"cli\"/\"template_data\"\n )\n cwd=pathlib.Path().cwd().absolute()\n filepath_pairs=[\n (\n filepath,\n cwd /str(filepath).replace(str(template_data_dir),\"\").lstrip(os.sep),\n )\n for filepath in map(pathlib.Path,_get_files(template_data_dir,\".py\"))\n ]\n \n files_exist=[p for _,p in filepath_pairs if p.exists()]\n if files_exist:\n  for p in files_exist:\n   print(p)\n  while True :\n   ans=input(\"Some files already exist. Will you overwrite them? (y/N): \")\n   if len(ans)==0 or (ans.isalpha()and ans.lower()in {\"y\",\"n\"}):\n    if len(ans)==0 or ans.lower()==\"n\":\n     sys.exit()\n    else :\n     break\n   else :\n    continue\n for template_filepath,project_filepath in filepath_pairs:\n  if not project_filepath.parent.exists():\n   os.makedirs(project_filepath.parent)\n  if project_filepath.exists():\n   os.remove(project_filepath)\n  shutil.copy(template_filepath,project_filepath)\n  print(project_filepath)\n", ["os", "pathlib", "shutil", "sys", "webcompy.cli._utils"]], "webcompy.cli._server": [".py", "import asyncio\nfrom functools import partial\nfrom operator import truth\nfrom re import compile as re_compile,escape as re_escape\nimport mimetypes\nimport pathlib\nfrom tempfile import TemporaryDirectory\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse,PlainTextResponse\nfrom starlette.routing import Route\nfrom starlette.exceptions import HTTPException\nfrom starlette.types import ASGIApp\nfrom sse_starlette.sse import EventSourceResponse\nimport uvicorn\nfrom webcompy.cli._argparser import get_params\nfrom webcompy.cli._brython_cli import (\ninstall_brython_scripts,\nmake_brython_package,\n)\nfrom webcompy.cli._config import WebComPyConfig\nfrom webcompy.cli._html import generate_html\nfrom webcompy.cli._utils import (\nget_app,\nget_config,\nget_webcompy_packge_dir,\n)\n\n\ndef create_asgi_app(config:WebComPyConfig,dev_mode:bool=False )->ASGIApp:\n app=get_app(config)\n \n with TemporaryDirectory()as temp:\n  install_brython_scripts(temp)\n  make_brython_package(get_webcompy_packge_dir(),temp)\n  make_brython_package(\n  str(pathlib.Path(f\"./{config.app_package}\").absolute()),temp\n  )\n  script_files:dict[str,tuple[bytes,str]]={\n  p.name:(\n  p.open(\"rb\").read(),\n  t if (t :=mimetypes.guess_type(p)[0])else \"application/octet-stream\",\n  )\n  for p in pathlib.Path(temp).iterdir()\n  }\n  \n async def send_script_file(request:Request):\n  filename:str=request.path_params.get(\"filename\",\"\")\n  if filename in script_files.keys():\n   content,media_type=script_files[filename]\n   return PlainTextResponse(content,media_type=media_type)\n  else :\n   raise HTTPException(404)\n   \n html_generator=partial(generate_html,config,dev_mode)\n base_url_stripper=partial(re_compile(\"^\"+re_escape(config.base)).sub,\"\")\n \n if app.__component__.router_mode ==\"history\"and app.__component__.routes:\n  html_route=(\n  config.base+\"/{path:path}\"if config.base !=\"/\"else \"/{path:path}\"\n  )\n  \n  async def send_html(request:Request):\n  \n   path:str=request.path_params.get(\"path\",\"\")\n   requested_path=base_url_stripper(path).strip(\"/\")\n   \n   accept_types:list[str]=request.headers.get(\"accept\",\"\").split(\",\")\n   \n   routes=r if (r :=app.__component__.routes)else []\n   is_matched=truth(tuple(filter(lambda r:r[1](requested_path),routes)))\n   \n   if is_matched or \"text/html\"in accept_types:\n    app.__component__.set_path(requested_path)\n    return HTMLResponse(html_generator(app,True ))\n   else :\n    raise HTTPException(404)\n    \n else :\n  html_route=config.base\n  html=html_generator(app,False )\n  \n  async def send_html(_:Request):\n   return HTMLResponse(html)\n   \n if (base :=config.base)!=\"/\":\n  base=f\"{base}/\"\n routes=[\n Route(base+\"scripts/{filename:path}\",send_script_file),\n Route(html_route,send_html),\n ]\n \n if dev_mode:\n \n  async def loop():\n   while True :\n    await asyncio.sleep(60)\n    yield None\n    \n  async def sse(_:Request):\n   return EventSourceResponse(loop())\n   \n  if config.base ==\"/\":\n   reload_route=\"/_webcompy_reload\"\n  else :\n   reload_route=f\"{config.base}/_webcompy_reload\"\n  routes.insert(0,Route(reload_route,endpoint=sse))\n  \n return Starlette(routes=routes)\n \n \ndef run_server():\n _,args=get_params()\n config=get_config()\n uvicorn.run(\n \"webcompy.cli._asgi_app:app\",\n host=\"0.0.0.0\",\n port=port if (port :=args[\"port\"])else config.server_port,\n reload=args[\"dev\"],\n )\n", ["asyncio", "functools", "mimetypes", "operator", "pathlib", "re", "sse_starlette.sse", "starlette.applications", "starlette.exceptions", "starlette.requests", "starlette.responses", "starlette.routing", "starlette.types", "tempfile", "uvicorn", "webcompy.cli._argparser", "webcompy.cli._brython_cli", "webcompy.cli._config", "webcompy.cli._html", "webcompy.cli._utils"]], "webcompy.cli._utils": [".py", "from importlib import import_module\nimport os\nimport pathlib\nimport sys\nfrom typing import Callable,ParamSpec,TypeVar\nfrom webcompy.cli._config import WebComPyConfig\nfrom webcompy.cli._exception import WebComPyCliException\nfrom webcompy.app._app import WebComPyApp\n\n\ndef get_config()->WebComPyConfig:\n try :\n  webcompy_config=import_module(\"webcompy_config\")\n except ModuleNotFoundError:\n  raise WebComPyCliException(\n  \"No python module named 'webcompy_config'\",\n  )\n configs=tuple(\n it\n for name in dir(webcompy_config)\n if isinstance(it :=getattr(webcompy_config,name),WebComPyConfig)\n )\n if len(configs)==0:\n  raise WebComPyCliException(\n  \"No WebComPyConfig instance in 'webcompy_config.py'\",\n  )\n elif len(configs)==0:\n  raise WebComPyCliException(\n  \"Multiple WebComPyConfig instances in 'webcompy_config.py'\"\n  )\n else :\n  config=configs[0]\n return config\n \n \ndef get_app(config:WebComPyConfig)->WebComPyApp:\n try :\n  import_module(config.app_package)\n except ModuleNotFoundError:\n  raise WebComPyCliException(\n  f\"No python module named '{config.app_package}'\",\n  )\n try :\n  bootstrap=import_module(config.app_package+\".bootstrap\")\n except AttributeError:\n  raise WebComPyCliException(\n  f\"No python module named 'bootstrap' in '{config.app_package}'\",\n  )\n app_instances=tuple(\n it\n for name in dir(bootstrap)\n if isinstance(it :=getattr(bootstrap,name),WebComPyApp)\n )\n if len(app_instances)==0:\n  raise WebComPyCliException(\n  \"No WebComPyApp instance in 'bootstrap.py'\",\n  )\n elif len(app_instances)==0:\n  raise WebComPyCliException(\n  \"Multiple WebComPyApp instances in 'bootstrap.py'\",\n  )\n else :\n  app=app_instances[0]\n return app\n \n \ndef get_webcompy_packge_dir(path:pathlib.Path |None =None )->str:\n if path is None :\n  path=pathlib.Path(__file__)\n if path.is_dir()and path.name ==\"webcompy\":\n  return str(path.absolute())\n else :\n  return get_webcompy_packge_dir(path.parent)\n  \n  \nP=ParamSpec(\"P\")\nT=TypeVar(\"T\")\n\n\ndef external_cli_tool_wrapper(func:Callable[P,T])->Callable[P,T]:\n def inner(*args:P.args,**kwargs:P.kwargs):\n  cwd_ori=pathlib.Path.cwd()\n  argv_ori=tuple(sys.argv[1:])\n  for _ in range(1,len(sys.argv)):\n   sys.argv.pop(1)\n  ret=func(*args,**kwargs)\n  for _ in range(1,len(sys.argv)):\n   sys.argv.pop(1)\n  for arg in argv_ori:\n   sys.argv.append(arg)\n  os.chdir(cwd_ori)\n  return ret\n  \n return inner\n", ["importlib", "os", "pathlib", "sys", "typing", "webcompy.app._app", "webcompy.cli._config", "webcompy.cli._exception"]], "webcompy.cli": [".py", "from webcompy.cli._config import WebComPyConfig\nfrom webcompy.cli._utils import get_app\nfrom webcompy.cli._server import create_asgi_app\n\n__all__=[\n\"WebComPyConfig\",\n\"get_app\",\n\"create_asgi_app\",\n]\n", ["webcompy.cli._config", "webcompy.cli._server", "webcompy.cli._utils"], 1], "webcompy.cli.template_data.webcompy_config": [".py", "from webcompy.cli import WebComPyConfig\n\nconfig=WebComPyConfig(\napp_package=\"app\",\nbase=\"/WebComPy\"\n)\n", ["webcompy.cli"]], "webcompy.cli.template_data.app.bootstrap": [".py", "from webcompy.app import WebComPyApp\nfrom .router import router\nfrom .components.root import Root\n\napp=WebComPyApp(\nroot_component=Root,\nrouter=router,\n)\napp.set_head(\n{\n\"title\":\"WebComPy Template\",\n\"meta\":[\n{\"charset\":\"utf-8\"},\n],\n}\n)\n", ["webcompy.app", "webcompy.cli.template_data.app.components.root", "webcompy.cli.template_data.app.router"]], "webcompy.cli.template_data.app.router": [".py", "from webcompy.router import Router\nfrom .components.home import Home\nfrom .components.fizzbuzz import Fizzbuzz\nfrom .components.input import InOutSample\nfrom .components.not_found import NotFound\n\nrouter=Router(\n{\"path\":\"/\",\"component\":Home},\n{\"path\":\"/fizzbuzz\",\"component\":Fizzbuzz},\n{\"path\":\"/input\",\"component\":InOutSample},\ndefault=NotFound,\nmode=\"history\",\nbase_url=\"/WebComPy\"\n)\n", ["webcompy.cli.template_data.app.components.fizzbuzz", "webcompy.cli.template_data.app.components.home", "webcompy.cli.template_data.app.components.input", "webcompy.cli.template_data.app.components.not_found", "webcompy.router"]], "webcompy.cli.template_data.app": [".py", "", [], 1], "webcompy.cli.template_data.app.components.fizzbuzz": [".py", "from webcompy.reactive import Reactive,computed_property,computed\nfrom webcompy.elements import html,repeat,switch\nfrom webcompy.components import (\ndefine_component,\nComponentContext,\nTypedComponentBase,\ncomponent_class,\non_before_rendering,\ncomponent_template,\n)\nfrom webcompy.router import RouterContext\nfrom webcompy.brython import DOMEvent\n\n\n@define_component\ndef FizzbuzzList(context:ComponentContext[Reactive[int]]):\n @computed\n def numbers():\n  li:list[str]=[]\n  for n in range(1,context.props.value+1):\n   if n %15 ==0:\n    li.append(\"FizzBuzz\")\n   elif n %5 ==0:\n    li.append(\"Fizz\")\n   elif n %3 ==0:\n    li.append(\"Buzz\")\n   else :\n    li.append(str(n))\n  return li\n  \n return html.DIV(\n {},\n html.UL(\n {},\n repeat(numbers,lambda s:html.LI({},s)),\n ),\n )\n \n \nFizzbuzzList.scoped_style={\n\"ul\":{\n\"border\":\"dashed 2px #668ad8\",\n\"background\":\"#f1f8ff\",\n\"padding\":\"0.5em 0.5em 0.5em 2em\",\n},\n\"ul > li:nth-child(3n)\":{\n\"color\":\"red\",\n},\n\"ul > li:nth-child(5n)\":{\n\"color\":\"blue\",\n},\n\"ul > li:nth-child(15n)\":{\n\"color\":\"purple\",\n},\n}\n\n\n@component_class\nclass Fizzbuzz(TypedComponentBase(props_type=RouterContext)):\n def __init__(self)->None :\n  self.opened=Reactive(True )\n  self.count=Reactive(10)\n  \n @computed_property\n def toggle_button_text(self):\n  return \"Hide\"if self.opened.value else \"Open\"\n  \n @on_before_rendering\n def on_before_rendering(self):\n  self.count.value=10\n  \n def add(self,ev:DOMEvent):\n  self.count.value +=1\n  \n def pop(self,ev:DOMEvent):\n  if self.count.value >0:\n   self.count.value -=1\n   \n def toggle(self,ev:DOMEvent):\n  self.opened.value=not self.opened.value\n  \n @component_template\n def template(self):\n  return html.DIV(\n  {},\n  html.H2(\n  {},\n  \"FizzBuzz\",\n  ),\n  html.P(\n  {},\n  html.BUTTON(\n  {\"@click\":self.toggle},\n  self.toggle_button_text,\n  ),\n  html.BUTTON(\n  {\"@click\":self.add},\n  \"Add\",\n  ),\n  html.BUTTON(\n  {\"@click\":self.pop},\n  \"Pop\",\n  ),\n  ),\n  html.P(\n  {},\n  \"Count: \",\n  self.count,\n  ),\n  switch(\n  {\n  \"case\":self.opened,\n  \"generator\":lambda :FizzbuzzList(props=self.count),\n  },\n  default=lambda :html.DIV(\n  {},\n  \"FizzBuzz Hidden\",\n  ),\n  ),\n  )\n", ["webcompy.brython", "webcompy.components", "webcompy.elements", "webcompy.reactive", "webcompy.router"]], "webcompy.cli.template_data.app.components.home": [".py", "from webcompy.elements import html\nfrom webcompy.components import define_component,ComponentContext\nfrom webcompy.router import RouterContext\n\n\n@define_component\ndef Home(_:ComponentContext[RouterContext]):\n return html.H3(\n {},\n \"WebCompy Template\",\n )\n", ["webcompy.components", "webcompy.elements", "webcompy.router"]], "webcompy.cli.template_data.app.components.input": [".py", "from webcompy.reactive import Reactive\nfrom webcompy.elements import html\nfrom webcompy.components import define_component,ComponentContext\nfrom webcompy.router import RouterContext\nfrom webcompy.brython import DOMEvent\n\n\n@define_component\ndef InOutSample(_:ComponentContext[RouterContext]):\n text=Reactive(\"\")\n \n def on_input(ev:DOMEvent):\n  text.value=ev.target.value\n  \n return html.DIV(\n {},\n html.H4({},\"Text Input Sample\"),\n html.P(\n {},\n \"Input: \",\n html.INPUT(\n {\"type\":\"text\",\"@input\":on_input},\n ),\n ),\n html.P(\n {},\n \"Output: \",\n text,\n ),\n )\n", ["webcompy.brython", "webcompy.components", "webcompy.elements", "webcompy.reactive", "webcompy.router"]], "webcompy.cli.template_data.app.components.navigation": [".py", "from webcompy.elements import html\nfrom webcompy.components import (\ncomponent_class,\nNonPropsComponentBase,\ncomponent_template,\n)\nfrom webcompy.router import RouterLink\n\n\n@component_class\nclass Navigation(NonPropsComponentBase):\n def __init__(self)->None :\n  pass\n  \n @component_template\n def template(self):\n  return html.NAV(\n  {},\n  html.UL(\n  {},\n  html.LI(\n  {},\n  RouterLink(\n  to=\"/\",\n  text=[\"Home\"],\n  ),\n  ),\n  html.LI(\n  {},\n  RouterLink(\n  to=\"/fizzbuzz\",\n  text=[\"FizzBuzz\"],\n  ),\n  ),\n  html.LI(\n  {},\n  RouterLink(\n  to=\"/input\",\n  text=[\"Text Input Sample\"],\n  ),\n  ),\n  ),\n  )\n", ["webcompy.components", "webcompy.elements", "webcompy.router"]], "webcompy.cli.template_data.app.components.not_found": [".py", "from webcompy.elements import html\nfrom webcompy.components import define_component,ComponentContext\nfrom webcompy.router import RouterContext\n\n\n@define_component\ndef NotFound(context:ComponentContext[RouterContext]):\n return html.DIV(\n {},\n html.H3(\n {},\n \"NotFound\",\n ),\n html.PRE(\n {},\n context.props.path,\n ),\n )\n", ["webcompy.components", "webcompy.elements", "webcompy.router"]], "webcompy.cli.template_data.app.components.root": [".py", "from webcompy.elements import html\nfrom webcompy.components import ComponentContext,define_component\nfrom webcompy.router import RouterView\nfrom .navigation import Navigation\n\n\n@define_component\ndef Root(_:ComponentContext[None ]):\n return html.DIV(\n {},\n Navigation(None ),\n RouterView(),\n )\n", ["webcompy.cli.template_data.app.components.navigation", "webcompy.components", "webcompy.elements", "webcompy.router"]], "webcompy.cli.template_data.app.components": [".py", "", [], 1], "webcompy.components._abstract": [".py", "import hashlib\nfrom typing import (\nAny,\nCallable,\nClassVar,\nFinal,\nGeneric,\nNoReturn,\nType,\nTypeAlias,\nTypeVar,\nfinal,\noverload,\n)\nfrom re import compile as re_compile\nfrom webcompy.components._libs import (\nClassStyleComponentContenxt,\nComponentProperty,\nWebComPyComponentException,\n)\nfrom webcompy.reactive._container import ReactiveReceivable\n\n\n_camel_to_kebab_pattern:Final=re_compile(\"((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))\")\n_combinator_pattern:Final=re_compile(r\"\\s*,\\s*|\\s*>\\s*|\\s*\\+\\s*|\\s*~[^=]\\s*|\\s* \\s*\")\n\nPropsType=TypeVar(\"PropsType\")\n\n\nclass ComponentAbstract(ReactiveReceivable,Generic[PropsType]):\n __webcompy_component_id__:ClassVar[str]\n \n __context:ClassStyleComponentContenxt[PropsType]\n \n name:str\n \n @final\n @property\n def context(self)->ClassStyleComponentContenxt[PropsType]:\n  return self.__context\n  \n @final\n def __new__(cls)->NoReturn:\n  raise WebComPyComponentException(\n  \"Component class cannot generate an instance by constructor\"\n  )\n  \n @final\n def __init_subclass__(cls)->None :\n  cls.__webcompy_component_id__=hashlib.md5(\n  cls.__get_name__().encode()\n  ).hexdigest()\n  return super().__init_subclass__()\n  \n @final\n @classmethod\n def __get_component_instance__(\n cls,context:ClassStyleComponentContenxt[PropsType]\n ):\n  component=super().__new__(cls)\n  component.__context=context\n  component.__init__()\n  return component\n  \n @final\n def __get_component_property__(self)->ComponentProperty:\n  def none():\n   return None\n   \n  props:dict[str,Callable[[],Any]]={\n  v.__webcompy_component_class_property__:v\n  for v in (getattr(self,n)for n in dir(self)if hasattr(self,n))\n  if hasattr(v,\"__webcompy_component_class_property__\")\n  }\n  return {\n  \"component_id\":self.__webcompy_component_id__,\n  \"component_name\":self.__get_name__(),\n  \"template\":props.get(\"template\",none)(),\n  \"on_before_rendering\":props.get(\"on_before_rendering\",lambda :none),\n  \"on_after_rendering\":props.get(\"on_after_rendering\",lambda :none),\n  \"on_before_destroy\":props.get(\"on_before_destroy\",lambda :none),\n  }\n  \n @classmethod\n def __get_name__(cls)->str:\n  return _camel_to_kebab_pattern.sub(\n  r\"-\\1\",\n  cls.name if hasattr(cls,\"name\")else cls.__name__,\n  ).lower()\n  \n  \nComponentBase:TypeAlias=ComponentAbstract[Any]\nNonPropsComponentBase:TypeAlias=ComponentAbstract[None ]\n\n\n@overload\ndef TypedComponentBase(\nprops_type:Type[PropsType],\n)->Type[ComponentAbstract[PropsType]]:\n ...\n \n \n@overload\ndef TypedComponentBase(\nprops_type:None ,\n)->Type[NonPropsComponentBase]:\n ...\n \n \ndef TypedComponentBase(\nprops_type:Type[PropsType]|None ,\n)->Type[ComponentAbstract[PropsType]]|Type[NonPropsComponentBase]:\n if props_type is None :\n  return NonPropsComponentBase\n else :\n  return ComponentAbstract[PropsType]\n  \n  \ndef deco(func:Callable[[],Callable[[],str]]):\n return func\n \n \n@deco\ndef func():\n hoge=\"hello\"\n return lambda :hoge\n", ["hashlib", "re", "typing", "webcompy.components._libs", "webcompy.reactive._container"]], "webcompy.components._component": [".py", "from typing import Any,Callable,Type,TypeAlias,TypeGuard,Union\nfrom webcompy.elements.types._element import ElementBase,Element\nfrom webcompy.components._libs import Context,ComponentProperty,generate_id\nfrom webcompy.components._abstract import ComponentAbstract\nfrom webcompy.elements.typealias._element_property import ElementChildren\nfrom webcompy.exception import WebComPyException\n\n\nFuncComponentDef:TypeAlias=Callable[[Context[Any]],ElementChildren]\nClassComponentDef:TypeAlias=Type[ComponentAbstract[Any]]\n\n\ndef _is_function_style_component_def(obj:Any)->TypeGuard[FuncComponentDef]:\n return callable(obj)and getattr(obj,\"__webcompy_componet_definition__\",None )\n \n \ndef _is_class_style_component_def(obj:Any)->TypeGuard[ClassComponentDef]:\n return isinstance(obj,type)and issubclass(obj,ComponentAbstract)\n \n \nclass Component(ElementBase):\n def __init__(\n self,\n component_def:Union[FuncComponentDef,ClassComponentDef],\n props:Any,\n slots:dict[str,Callable[[],ElementChildren]],\n )->None :\n  self._attrs={}\n  self._event_handlers={}\n  self._ref=None\n  self._children=[]\n  super().__init__()\n  self.__init_component(self.__setup(component_def,props,slots))\n  \n def __setup(\n self,\n component_def:Union[FuncComponentDef,ClassComponentDef],\n props:Any,\n slots:dict[str,Callable[[],ElementChildren]],\n )->ComponentProperty:\n  if _is_class_style_component_def(component_def):\n   return component_def.__get_component_instance__(\n   Context(props,slots,component_def.__get_name__())\n   ).__get_component_property__()\n  elif _is_function_style_component_def(component_def):\n   component_name=component_def.__name__\n   context=Context(props,slots,component_name)\n   template=component_def(context)\n   hooks=context.__get_lifecyclehooks__()\n   return {\n   \"component_id\":generate_id(component_name),\n   \"component_name\":component_name,\n   \"template\":template,\n   \"on_before_rendering\":hooks.get(\"on_before_rendering\",lambda :None ),\n   \"on_after_rendering\":hooks.get(\"on_after_rendering\",lambda :None ),\n   \"on_before_destroy\":hooks.get(\"on_before_destroy\",lambda :None ),\n   }\n  else :\n   raise WebComPyException(\"Invalid Component Definition\")\n   \n def __init_component(self,property:ComponentProperty):\n  node=property[\"template\"]\n  if not isinstance(node,Element):\n   raise WebComPyException(\n   \"Root Node of Component must be instance of 'Element'\"\n   )\n  self._tag_name=node._tag_name\n  self._attrs={\n  **node._attrs,\n  \"webcompy-component\":property[\"component_name\"],\n  \"webcompy-cid-\"+property[\"component_id\"]:True ,\n  }\n  self._event_handlers=node._event_handlers\n  self._ref=node._ref\n  self._init_children(node._children)\n  self._property=property\n  \n def _render(self):\n  self._property[\"on_before_rendering\"]()\n  super()._render()\n  self._property[\"on_after_rendering\"]()\n  \n def _remove_element(self,recursive:bool=True ,remove_node:bool=True ):\n  self._property[\"on_before_destroy\"]()\n  super()._remove_element(recursive,remove_node)\n  \n def _get_belonging_component(self):\n  return self._property[\"component_id\"]\n  \n def _get_belonging_components(self)->tuple[\"Component\",...]:\n  return (*self._parent._get_belonging_components(),self)\n", ["typing", "webcompy.components._abstract", "webcompy.components._libs", "webcompy.elements.typealias._element_property", "webcompy.elements.types._element", "webcompy.exception"]], "webcompy.components._decorators": [".py", "from functools import wraps\nfrom typing import Any,Callable\nfrom webcompy.elements.types._element import Element\n\n\ndef component_template(method:Callable[[Any],Element]):\n @wraps(method)\n def inner(self:Any)->Element:\n  return method(self)\n  \n setattr(inner,\"__webcompy_component_class_property__\",\"template\")\n return inner\n \n \ndef on_before_rendering(method:Callable[[Any],None ]):\n @wraps(method)\n def inner(self:Any):\n  method(self)\n  \n setattr(\n inner,\n \"__webcompy_component_class_property__\",\n \"on_before_rendering\",\n )\n return inner\n \n \ndef on_after_rendering(method:Callable[[Any],None ]):\n @wraps(method)\n def inner(self:Any):\n  method(self)\n  \n setattr(\n inner,\n \"__webcompy_component_class_property__\",\n \"on_after_rendering\",\n )\n return inner\n \n \ndef on_before_destroy(method:Callable[[Any],None ]):\n @wraps(method)\n def inner(self:Any):\n  method(self)\n  \n setattr(inner,\"__webcompy_component_class_property__\",\"on_before_destroy\")\n return inner\n", ["functools", "typing", "webcompy.elements.types._element"]], "webcompy.components._generator": [".py", "from re import compile as re_compile\nfrom typing import (\nAny,\nCallable,\nFinal,\nGeneric,\nType,\nTypeAlias,\nTypeVar,\nUnion,\n)\nfrom webcompy.components._component import Component\nfrom webcompy.components._abstract import ComponentAbstract\nfrom webcompy.components._libs import (ComponentContext,NodeGenerator,WebComPyComponentException,generate_id)\nfrom webcompy.elements.typealias._element_property import ElementChildren\n\n\n_camel_to_kebab_pattern:Final=re_compile(\"((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))\")\n_combinator_pattern:Final=re_compile(r\"\\s*,\\s*|\\s*>\\s*|\\s*\\+\\s*|\\s*~[^=]\\s*|\\s* \\s*\")\n\n\nT=TypeVar(\"T\")\n\n\ndef _instantiate(cls:Type[T])->T:\n return cls()\n \n \n@_instantiate\nclass ComponentStore:\n __conponents:dict[str,\"ComponentGenerator[Any]\"]\n \n def __init__(self)->None :\n  self.__conponents={}\n  \n def add_component(self,name:str,componet_generator:\"ComponentGenerator[Any]\"):\n  if name in self.__conponents.keys():\n   raise WebComPyComponentException(f\"Duplicated Component Name: '{name}'\")\n  self.__conponents[name]=componet_generator\n  \n @property\n def components(self)->dict[str,\"ComponentGenerator[Any]\"]:\n  return self.__conponents\n  \n  \nPropsType=TypeVar(\"PropsType\")\nFuncComponentDef:TypeAlias=Callable[[ComponentContext[PropsType]],ElementChildren]\nClassComponentDef:TypeAlias=Type[ComponentAbstract[PropsType]]\n\n\nclass ComponentGenerator(Generic[PropsType]):\n __name:str\n __id:str\n __style:dict[str,dict[str,str]]\n \n def __init__(\n self,\n name:str,\n component_def:Union[FuncComponentDef[PropsType],ClassComponentDef[PropsType]],\n )->None :\n  self.__style={}\n  self.__component_def=component_def\n  self.__name:str=name\n  self.__id=generate_id(name)\n  ComponentStore.add_component(self.__name,self)\n  \n def __call__(\n self,\n props:PropsType,\n *,\n slots:dict[str,NodeGenerator]|None =None ,\n ):\n  return Component(self.__component_def,props,{**slots}if slots else {})\n  \n @property\n def scoped_style(self)->str:\n  style=self.__style\n  return \"\\n\".join(\n  f\"{selector} {{ \"\n  +\" \".join(f\"{name}: {value};\"for name,value in props.items())\n  +\" }\"\n  for selector,props in style.items()\n  )\n  \n @scoped_style.setter\n def scoped_style(self,style:dict[str,dict[str,str]]):\n  cid=self.__id\n  self.__style=dict(\n  zip(\n  (\n  \"\".join(\n  f\"{selector}[webcompy-cid-{cid}]{combinator}\"\n  for selector,combinator in zip(\n  _combinator_pattern.split(selector),\n  _combinator_pattern.findall(selector)+[\"\"],\n  )\n  )\n  for selector in map(lambda s:s.strip(),style.keys())\n  ),\n  (\n  {\n  prop:value.strip().rstrip(\";\").rstrip()\n  for prop,value in declaration.items()\n  }\n  for declaration in style.values()\n  ),\n  )\n  )\n  \n  \ndef define_component(\nsetup:Callable[[ComponentContext[PropsType]],ElementChildren],\n)->ComponentGenerator[PropsType]:\n setattr(setup,\"__webcompy_componet_definition__\",True )\n return ComponentGenerator(setup.__name__,setup)\n \n \ndef component_class(\ncomponent_def:Type[ComponentAbstract[PropsType]],\n)->ComponentGenerator[PropsType]:\n return ComponentGenerator(component_def.__get_name__(),component_def)\n", ["re", "typing", "webcompy.components._abstract", "webcompy.components._component", "webcompy.components._libs", "webcompy.elements.typealias._element_property"]], "webcompy.components._libs": [".py", "import hashlib\nimport logging\nfrom typing import (\nAny,\nCallable,\nDict,\nGeneric,\nLiteral,\nProtocol,\nTypeAlias,\nTypeVar,\nTypedDict,\nfinal,\n)\nfrom webcompy.exception import WebComPyException\nfrom webcompy.elements.typealias._element_property import ElementChildren\n\n\nclass WebComPyComponentException(WebComPyException):\n pass\n \n \nNodeGenerator:TypeAlias=Callable[[],ElementChildren]\n_Lifecyclehooks:TypeAlias=dict[\nLiteral[\"on_before_rendering\",\"on_after_rendering\",\"on_before_destroy\"],\nCallable[[],Any],\n]\n\nPropsType=TypeVar(\"PropsType\",covariant=True )\n\n\n@final\nclass Context(Generic[PropsType]):\n __slots:dict[str,NodeGenerator]\n __props:PropsType\n \n __on_before_rendering:Callable[[],Any]|None\n __on_after_rendering:Callable[[],Any]|None\n __on_before_destroy:Callable[[],Any]|None\n \n def __init__(\n self,\n props:PropsType,\n slots:Dict[str,NodeGenerator],\n component_name:str,\n )->None :\n  self.__props=props\n  self.__slots=slots\n  self._component_name=component_name\n  self.__on_before_rendering=None\n  self.__on_after_rendering=None\n  self.__on_before_destroy=None\n  \n @property\n def props(self)->PropsType:\n  return self.__props\n  \n def slots(\n self,\n name:str,\n fallback:NodeGenerator |None =None ,\n )->ElementChildren:\n  if name in self.__slots:\n   return self.__slots[name]()\n  elif fallback is not None :\n   return fallback()\n  else :\n   logging.warning(\n   f\"Componet '{self._component_name}' is not given a slot named '{name}'\"\n   )\n   return None\n   \n def on_before_rendering(self,func:Callable[[],Any])->None :\n  self.__on_before_rendering=func\n  \n def on_after_rendering(self,func:Callable[[],Any])->None :\n  self.__on_after_rendering=func\n  \n def on_before_destroy(self,func:Callable[[],Any])->None :\n  self.__on_before_destroy=func\n  \n def __get_lifecyclehooks__(self)->_Lifecyclehooks:\n  hooks:_Lifecyclehooks={}\n  if self.__on_before_rendering:\n   hooks[\"on_before_rendering\"]=self.__on_before_rendering\n  if self.__on_after_rendering:\n   hooks[\"on_after_rendering\"]=self.__on_after_rendering\n  if self.__on_before_destroy:\n   hooks[\"on_before_destroy\"]=self.__on_before_destroy\n  return hooks\n  \n  \nclass ComponentContext(Protocol[PropsType]):\n @property\n def props(self)->PropsType:\n  ...\n  \n def slots(\n self,\n name:str,\n fallback:NodeGenerator |None =None ,\n )->ElementChildren:\n  ...\n  \n def on_before_rendering(self,func:Callable[[],Any])->None :\n  ...\n  \n def on_after_rendering(self,func:Callable[[],Any])->None :\n  ...\n  \n def on_before_destroy(self,func:Callable[[],Any])->None :\n  ...\n  \n  \nclass ClassStyleComponentContenxt(Protocol[PropsType]):\n @property\n def props(self)->PropsType:\n  ...\n  \n def slots(\n self,\n name:str,\n fallback:NodeGenerator |None =None ,\n )->ElementChildren:\n  ...\n  \n  \n@final\nclass ComponentProperty(TypedDict):\n component_id:str\n component_name:str\n template:ElementChildren\n on_before_rendering:Callable[[],None ]\n on_after_rendering:Callable[[],None ]\n on_before_destroy:Callable[[],None ]\n \n \ndef generate_id(component_name:str)->str:\n return hashlib.md5(component_name.encode()).hexdigest()\n", ["hashlib", "logging", "typing", "webcompy.elements.typealias._element_property", "webcompy.exception"]], "webcompy.components": [".py", "from webcompy.components._abstract import (\nComponentBase,\nNonPropsComponentBase,\nTypedComponentBase,\n)\nfrom webcompy.components._component import Component\nfrom webcompy.components._libs import (\nComponentContext,\nClassStyleComponentContenxt,\nComponentProperty,\nWebComPyComponentException,\n)\nfrom webcompy.components._decorators import (\ncomponent_template,\non_before_rendering,\non_after_rendering,\non_before_destroy,\n)\nfrom webcompy.components._generator import (\nComponentGenerator,\ncomponent_class,\ndefine_component,\n)\n\n\n__all__=[\n\"define_component\",\n\"ComponentContext\",\n\"ComponentBase\",\n\"NonPropsComponentBase\",\n\"TypedComponentBase\",\n\"component_class\",\n\"component_template\",\n\"on_before_rendering\",\n\"on_after_rendering\",\n\"on_before_destroy\",\n\"ComponentGenerator\",\n\"WebComPyComponentException\",\n\"Component\",\n\"ClassStyleComponentContenxt\",\n\"ComponentProperty\",\n]\n", ["webcompy.components._abstract", "webcompy.components._component", "webcompy.components._decorators", "webcompy.components._generator", "webcompy.components._libs"], 1], "webcompy.elements.generators": [".py", "from typing import (\nAny,\nCallable,\nDict,\nList,\nNewType,\nTypeAlias,\nTypeVar,\nTypedDict,\nUnion,\n)\nfrom webcompy.elements.types._text import TextElement,NewLine\nfrom webcompy.elements.types._element import ElementBase,Element\nfrom webcompy.elements.types._refference import DomNodeRef\nfrom webcompy.elements.types._repeat import RepeatElement,MultiLineTextElement\nfrom webcompy.elements.types._switch import SwitchElement\nfrom webcompy.elements.typealias._html_tag_names import HtmlTags\nfrom webcompy.elements.typealias._element_property import (\nAttrValue,\nEventHandler,\nElementChildren,\n)\nfrom webcompy.reactive import ReactiveBase\n\n\nT=TypeVar(\"T\")\n\nEventKey=NewType(\"EventKey\",str)\n_ref=NewType(\"DomNodeRefKey\",str)\nnoderef=_ref(\":ref\")\n\n\ndef event(event_name:str):\n return EventKey(f\"@{event_name}\")\n \n \ndef create_element(\ntag_name:HtmlTags,\n/,\nattributes:Dict[str |EventKey |_ref,AttrValue |EventHandler |DomNodeRef],\n*children:ElementChildren,\n)->Element:\n attrs:Dict[str,AttrValue]={}\n events:Dict[str,EventHandler]={}\n ref:DomNodeRef |None =None\n for name,value in attributes.items():\n  if isinstance(value,DomNodeRef):\n   if name ==\":ref\":\n    ref=value\n  elif callable(value):\n   if name.startswith(\"@\"):\n    events[name[1:]]=value\n  else :\n   attrs[name]=value\n return Element(tag_name,attrs,events,ref,children)\n \n \nChildNode:TypeAlias=Union[\nElementBase,\nTextElement,\nMultiLineTextElement,\nNewLine,\nReactiveBase[Any],\nstr,\nNone ,\n]\nNodeGenerator:TypeAlias=Callable[[],ChildNode]\n\n\ndef repeat(\nsequence:ReactiveBase[List[T]],\ntemplate:Callable[[T],ChildNode],\n):\n return RepeatElement(sequence,template)\n \n \nclass SwitchCase(TypedDict):\n case:ReactiveBase[Any]\n generator:NodeGenerator\n \n \ndef switch(\n*cases:SwitchCase,\ndefault:NodeGenerator |None =None ,\n):\n return SwitchElement(\n [(case[\"case\"],case[\"generator\"])for case in cases],\n default,\n )\n \n \ndef text(text:str |ReactiveBase[Any],enable_multiline:bool=True ):\n if enable_multiline:\n  return MultiLineTextElement(text)\n else :\n  return TextElement(text)\n  \n  \ndef break_line():\n return NewLine()\n", ["typing", "webcompy.elements.typealias._element_property", "webcompy.elements.typealias._html_tag_names", "webcompy.elements.types._element", "webcompy.elements.types._refference", "webcompy.elements.types._repeat", "webcompy.elements.types._switch", "webcompy.elements.types._text", "webcompy.reactive"]], "webcompy.elements": [".py", "from webcompy.elements.types._refference import DomNodeRef\nfrom webcompy.elements import types\nfrom webcompy.elements import typealias\nfrom webcompy.elements.generators import (\nevent,\nnoderef,\ncreate_element,\nrepeat,\nswitch,\ntext,\nbreak_line,\n)\nfrom webcompy.elements import html\n\n\n__all__=[\n\"types\",\n\"typealias\",\n\"html\",\n\"event\",\n\"noderef\",\n\"create_element\",\n\"repeat\",\n\"switch\",\n\"text\",\n\"break_line\",\n\"DomNodeRef\",\n]\n", ["webcompy.elements", "webcompy.elements.generators", "webcompy.elements.types._refference"], 1], "webcompy.elements.html.html_tags": [".py", "from functools import partial\nfrom webcompy.elements.generators import create_element,text,break_line\n\n\nTEXT=text\nBR=lambda :break_line()\nADDRESS=partial(create_element,\"address\")\nARTICLE=partial(create_element,\"article\")\nASIDE=partial(create_element,\"aside\")\nFOOTER=partial(create_element,\"footer\")\nHEADER=partial(create_element,\"header\")\nH1=partial(create_element,\"h1\")\nH2=partial(create_element,\"h2\")\nH3=partial(create_element,\"h3\")\nH4=partial(create_element,\"h4\")\nH5=partial(create_element,\"h5\")\nH6=partial(create_element,\"h6\")\nMAIN=partial(create_element,\"main\")\nNAV=partial(create_element,\"nav\")\nSECTION=partial(create_element,\"section\")\nBLOCKQUOTE=partial(create_element,\"blockquote\")\nDD=partial(create_element,\"dd\")\nDIV=partial(create_element,\"div\")\nDL=partial(create_element,\"dl\")\nDT=partial(create_element,\"dt\")\nFIGCAPTION=partial(create_element,\"figcaption\")\nFIGURE=partial(create_element,\"figure\")\nHR=partial(create_element,\"hr\")\nLI=partial(create_element,\"li\")\nMENU=partial(create_element,\"menu\")\nOL=partial(create_element,\"ol\")\nP=partial(create_element,\"p\")\nPRE=partial(create_element,\"pre\")\nUL=partial(create_element,\"ul\")\nA=partial(create_element,\"a\")\nABBR=partial(create_element,\"abbr\")\nB=partial(create_element,\"b\")\nBDI=partial(create_element,\"bdi\")\nBDO=partial(create_element,\"bdo\")\nCITE=partial(create_element,\"cite\")\nCODE=partial(create_element,\"code\")\nDATA=partial(create_element,\"data\")\nDFN=partial(create_element,\"dfn\")\nEM=partial(create_element,\"em\")\nI=partial(create_element,\"i\")\nKBD=partial(create_element,\"kbd\")\nMARK=partial(create_element,\"mark\")\nQ=partial(create_element,\"q\")\nRP=partial(create_element,\"rp\")\nRT=partial(create_element,\"rt\")\nRUBY=partial(create_element,\"ruby\")\nS=partial(create_element,\"s\")\nSAMP=partial(create_element,\"samp\")\nSMALL=partial(create_element,\"small\")\nSPAN=partial(create_element,\"span\")\nSTRONG=partial(create_element,\"strong\")\nSUB=partial(create_element,\"sub\")\nSUP=partial(create_element,\"sup\")\nTIME=partial(create_element,\"time\")\nU=partial(create_element,\"u\")\nVAR=partial(create_element,\"var\")\nWBR=partial(create_element,\"wbr\")\nAREA=partial(create_element,\"area\")\nAUDIO=partial(create_element,\"audio\")\nIMG=partial(create_element,\"img\")\nMAP=partial(create_element,\"map\")\nTRACK=partial(create_element,\"track\")\nVIDEO=partial(create_element,\"video\")\nEMBED=partial(create_element,\"embed\")\nIFRAME=partial(create_element,\"iframe\")\nOBJECT=partial(create_element,\"object\")\nPARAM=partial(create_element,\"param\")\nPICTURE=partial(create_element,\"picture\")\nPORTAL=partial(create_element,\"portal\")\nSOURCE=partial(create_element,\"source\")\nSVG=partial(create_element,\"svg\")\nMATH=partial(create_element,\"math\")\nCANVAS=partial(create_element,\"canvas\")\nDEL=partial(create_element,\"del\")\nINS=partial(create_element,\"ins\")\nCAPTION=partial(create_element,\"caption\")\nCOL=partial(create_element,\"col\")\nCOLGROUP=partial(create_element,\"colgroup\")\nTABLE=partial(create_element,\"table\")\nTBODY=partial(create_element,\"tbody\")\nTD=partial(create_element,\"td\")\nTFOOT=partial(create_element,\"tfoot\")\nTH=partial(create_element,\"th\")\nTHEAD=partial(create_element,\"thead\")\nTR=partial(create_element,\"tr\")\nBUTTON=partial(create_element,\"button\")\nDATALIST=partial(create_element,\"datalist\")\nFIELDSET=partial(create_element,\"fieldset\")\nFORM=partial(create_element,\"form\")\nINPUT=partial(create_element,\"input\")\nLABEL=partial(create_element,\"label\")\nLEGEND=partial(create_element,\"legend\")\nMETER=partial(create_element,\"meter\")\nOPTGROUP=partial(create_element,\"optgroup\")\nOPTION=partial(create_element,\"option\")\nOUTPUT=partial(create_element,\"output\")\nPROGRESS=partial(create_element,\"progress\")\nSELECT=partial(create_element,\"select\")\nTEXTAREA=partial(create_element,\"textarea\")\nDETAILS=partial(create_element,\"details\")\nDIALOG=partial(create_element,\"dialog\")\nSUMMARY=partial(create_element,\"summary\")\n", ["functools", "webcompy.elements.generators"]], "webcompy.elements.html": [".py", "\nfrom webcompy.elements.html.html_tags import (\nADDRESS,\nARTICLE,\nASIDE,\nFOOTER,\nHEADER,\nH1,\nH2,\nH3,\nH4,\nH5,\nH6,\nMAIN,\nNAV,\nSECTION,\n)\n\n\nfrom webcompy.elements.html.html_tags import (\nBLOCKQUOTE,\nDD,\nDIV,\nDL,\nDT,\nFIGCAPTION,\nFIGURE,\nHR,\nLI,\nMENU,\nOL,\nP,\nPRE,\nUL,\n)\n\n\nfrom webcompy.elements.html.html_tags import (\nTEXT,\nA,\nABBR,\nB,\nBDI,\nBDO,\nBR,\nCITE,\nCODE,\nDATA,\nDFN,\nEM,\nI,\nKBD,\nMARK,\nQ,\nRP,\nRT,\nRUBY,\nS,\nSAMP,\nSMALL,\nSPAN,\nSTRONG,\nSUB,\nSUP,\nTIME,\nU,\nVAR,\nWBR,\n)\n\n\nfrom webcompy.elements.html.html_tags import AREA,AUDIO,IMG,MAP,TRACK,VIDEO\n\n\nfrom webcompy.elements.html.html_tags import (\nEMBED,\nIFRAME,\nOBJECT,\nPARAM,\nPICTURE,\nPORTAL,\nSOURCE,\n)\n\n\nfrom webcompy.elements.html.html_tags import SVG,MATH\n\n\nfrom webcompy.elements.html.html_tags import CANVAS\n\n\nfrom webcompy.elements.html.html_tags import DEL,INS\n\n\nfrom webcompy.elements.html.html_tags import (\nCAPTION,\nCOL,\nCOLGROUP,\nTABLE,\nTBODY,\nTD,\nTFOOT,\nTH,\nTHEAD,\nTR,\n)\n\n\nfrom webcompy.elements.html.html_tags import (\nBUTTON,\nDATALIST,\nFIELDSET,\nFORM,\nINPUT,\nLABEL,\nLEGEND,\nMETER,\nOPTGROUP,\nOPTION,\nOUTPUT,\nPROGRESS,\nSELECT,\nTEXTAREA,\n)\n\n\nfrom webcompy.elements.html.html_tags import (\nDETAILS,\nDIALOG,\nSUMMARY,\n)\n\n\n__all__=[\n\"ADDRESS\",\n\"ARTICLE\",\n\"ASIDE\",\n\"FOOTER\",\n\"HEADER\",\n\"H1\",\n\"H2\",\n\"H3\",\n\"H4\",\n\"H5\",\n\"H6\",\n\"MAIN\",\n\"NAV\",\n\"SECTION\",\n\"BLOCKQUOTE\",\n\"DD\",\n\"DIV\",\n\"DL\",\n\"DT\",\n\"FIGCAPTION\",\n\"FIGURE\",\n\"HR\",\n\"LI\",\n\"MENU\",\n\"OL\",\n\"P\",\n\"PRE\",\n\"UL\",\n\"TEXT\",\n\"A\",\n\"ABBR\",\n\"B\",\n\"BDI\",\n\"BDO\",\n\"BR\",\n\"CITE\",\n\"CODE\",\n\"DATA\",\n\"DFN\",\n\"EM\",\n\"I\",\n\"KBD\",\n\"MARK\",\n\"Q\",\n\"RP\",\n\"RT\",\n\"RUBY\",\n\"S\",\n\"SAMP\",\n\"SMALL\",\n\"SPAN\",\n\"STRONG\",\n\"SUB\",\n\"SUP\",\n\"TIME\",\n\"U\",\n\"VAR\",\n\"WBR\",\n\"AREA\",\n\"AUDIO\",\n\"IMG\",\n\"MAP\",\n\"TRACK\",\n\"VIDEO\",\n\"EMBED\",\n\"IFRAME\",\n\"OBJECT\",\n\"PARAM\",\n\"PICTURE\",\n\"PORTAL\",\n\"SOURCE\",\n\"SVG\",\n\"MATH\",\n\"CANVAS\",\n\"DEL\",\n\"INS\",\n\"CAPTION\",\n\"COL\",\n\"COLGROUP\",\n\"TABLE\",\n\"TBODY\",\n\"TD\",\n\"TFOOT\",\n\"TH\",\n\"THEAD\",\n\"TR\",\n\"BUTTON\",\n\"DATALIST\",\n\"FIELDSET\",\n\"FORM\",\n\"INPUT\",\n\"LABEL\",\n\"LEGEND\",\n\"METER\",\n\"OPTGROUP\",\n\"OPTION\",\n\"OUTPUT\",\n\"PROGRESS\",\n\"SELECT\",\n\"TEXTAREA\",\n\"DETAILS\",\n\"DIALOG\",\n\"SUMMARY\",\n]\n", ["webcompy.elements.html.html_tags"], 1], "webcompy.elements.typealias._element_property": [".py", "from typing import (\nAny,\nCallable,\nCoroutine,\nTypeAlias,\nUnion,\n)\nfrom webcompy.reactive._base import ReactiveBase\nfrom webcompy.brython import DOMEvent\nfrom webcompy.elements.types._abstract import ElementAbstract\n\n\nElementChildren:TypeAlias=Union[ElementAbstract,ReactiveBase[Any],str,None ]\nAttrValue:TypeAlias=Union[ReactiveBase[Any],str,int,bool]\nEventHandler:TypeAlias=Union[\nCallable[[DOMEvent],Any],\nCallable[[DOMEvent],Coroutine[Any,Any,Any]],\n]\n", ["typing", "webcompy.brython", "webcompy.elements.types._abstract", "webcompy.reactive._base"]], "webcompy.elements.typealias._html_tag_names": [".py", "from typing import Literal,TypeAlias\n\n\nHtmlTags:TypeAlias=Literal[\n\n\"address\",\n\"article\",\n\"aside\",\n\"footer\",\n\"header\",\n\"h1\",\n\"h2\",\n\"h3\",\n\"h4\",\n\"h5\",\n\"h6\",\n\"main\",\n\"nav\",\n\"section\",\n\n\"blockquote\",\n\"dd\",\n\"div\",\n\"dl\",\n\"dt\",\n\"figcaption\",\n\"figure\",\n\"hr\",\n\"li\",\n\"menu\",\n\"ol\",\n\"p\",\n\"pre\",\n\"ul\",\n\n\"a\",\n\"abbr\",\n\"b\",\n\"bdi\",\n\"bdo\",\n\"cite\",\n\"code\",\n\"data\",\n\"dfn\",\n\"em\",\n\"i\",\n\"kbd\",\n\"mark\",\n\"q\",\n\"rp\",\n\"rt\",\n\"ruby\",\n\"s\",\n\"samp\",\n\"small\",\n\"span\",\n\"strong\",\n\"sub\",\n\"sup\",\n\"time\",\n\"u\",\n\"var\",\n\"wbr\",\n\n\"area\",\n\"audio\",\n\"img\",\n\"map\",\n\"track\",\n\"video\",\n\n\"embed\",\n\"iframe\",\n\"object\",\n\"param\",\n\"picture\",\n\"portal\",\n\"source\",\n\n\"svg\",\n\"math\",\n\n\"canvas\",\n\n\"del\",\n\"ins\",\n\n\"caption\",\n\"col\",\n\"colgroup\",\n\"table\",\n\"tbody\",\n\"td\",\n\"tfoot\",\n\"th\",\n\"thead\",\n\"tr\",\n\n\"button\",\n\"datalist\",\n\"fieldset\",\n\"form\",\n\"input\",\n\"label\",\n\"legend\",\n\"meter\",\n\"optgroup\",\n\"option\",\n\"output\",\n\"progress\",\n\"select\",\n\"textarea\",\n\n\"details\",\n\"dialog\",\n\"summary\",\n]\n", ["typing"]], "webcompy.elements.typealias": [".py", "from webcompy.elements.typealias._html_tag_names import HtmlTags\nfrom webcompy.elements.typealias._element_property import (\nElementChildren,\nAttrValue,\nEventHandler,\n)\n\n\n__all__=[\n\"HtmlTags\",\n\"ElementChildren\",\n\"AttrValue\",\n\"EventHandler\",\n]\n", ["webcompy.elements.typealias._element_property", "webcompy.elements.typealias._html_tag_names"], 1], "webcompy.elements.types._abstract": [".py", "from __future__ import annotations\nfrom abc import abstractmethod\nfrom typing import cast\nfrom webcompy.reactive._base import ReactiveStore\nfrom webcompy.reactive._container import ReactiveReceivable\nfrom webcompy.brython import DOMNode,browser\nfrom webcompy.exception import WebComPyException\n\n\nclass ElementAbstract(ReactiveReceivable):\n _node_idx:int\n _node_cache:DOMNode |None =None\n _mounted:bool |None =None\n _remount_to:DOMNode |None =None\n _callback_ids:set[int]\n __parent:ElementAbstract\n \n def __init__(self)->None :\n  self._node_cache=None\n  self._mounted=None\n  self._remount_to=None\n  self._callback_ids:set[int]=set()\n  \n @property\n def _parent(self)->\"ElementAbstract\":\n  return self.__parent\n  \n @_parent.setter\n def _parent(self,parent:\"ElementAbstract\"):\n  self.__parent=parent\n  \n def _render(self):\n  self._mount_node()\n  \n def _mount_node(self):\n  if not self._mounted and (node :=self._get_node()):\n   parent_node=self._parent._get_node()\n   if self._mounted is None :\n    if parent_node.childNodes.length <=self._node_idx:\n     parent_node.appendChild(node)\n    else :\n     next_node=parent_node.childNodes[self._node_idx]\n     parent_node.insertBefore(node,next_node)\n   elif not self._mounted and self._remount_to:\n    parent_node.replaceChild(node,self._remount_to)\n    self._remount_to=None\n   self._mounted=True\n   \n def _detach_node(self):\n  if browser and self._node_cache:\n   parent_node=self._parent._get_node()\n   self._remount_to=cast(DOMNode,browser.document.createTextNode(\"\"))\n   parent_node.replaceChild(self._remount_to,self._node_cache)\n   self._mounted=False\n  else :\n   raise WebComPyException(\"Not in Browser environment.\")\n   \n @abstractmethod\n def _init_node(self)->DOMNode:\n  ...\n  \n def _set_callback_id(self,callback_id:int):\n  self._callback_ids.add(callback_id)\n  \n def _remove_element(self,recursive:bool=True ,remove_node:bool=True ):\n  for callback_id in self._callback_ids:\n   ReactiveStore.remove_callback(callback_id)\n  if remove_node:\n   node=self._get_node()\n   if node:\n    node.remove()\n  self._clear_node_cache(False )\n  self.__purge_reactive_members__()\n  del self\n  \n @property\n def _node_count(self)->int:\n  return 1\n  \n def _get_node(self)->DOMNode:\n  if not self._node_cache:\n   self._node_cache=self._init_node()\n  return self._node_cache\n  \n def _clear_node_cache(self,recursive:bool=True ):\n  self._node_cache=None\n  \n def _get_prerendered_node(self)->DOMNode |None :\n  parent_node=self._parent._get_node()\n  if parent_node.childNodes.length >self._node_idx:\n   prerendered_node:DOMNode=parent_node.childNodes[self._node_idx]\n   return prerendered_node\n  return None\n  \n @abstractmethod\n def _render_html(\n self,newline:bool=False ,indent:int=2,count:int=0\n )->str:\n  ...\n", ["__future__", "abc", "typing", "webcompy.brython", "webcompy.exception", "webcompy.reactive._base", "webcompy.reactive._container"]], "webcompy.elements.types._base": [".py", "from __future__ import annotations\nfrom typing import Any\nfrom webcompy.reactive._base import ReactiveBase\nfrom webcompy.elements.types._abstract import ElementAbstract\nfrom webcompy.elements.typealias._html_tag_names import HtmlTags\nfrom webcompy.elements.typealias._element_property import (\nElementChildren,\nAttrValue,\nEventHandler,\n)\nfrom webcompy.elements.types._text import TextElement\n\n\nclass ElementWithChildren(ElementAbstract):\n _tag_name:HtmlTags\n _attrs:dict[str,AttrValue]={}\n _event_handlers:dict[str,EventHandler]={}\n _children:list[ElementAbstract]=[]\n __parent:ElementWithChildren\n \n def __init__(self)->None :\n  self._node_cache=None\n  self._callback_ids:set[int]=set()\n  \n @property\n def _parent(self)->\"ElementWithChildren\":\n  return self.__parent\n  \n @_parent.setter\n def _parent(self,parent:\"ElementWithChildren\"):\n  self.__parent=parent\n  \n def _render(self):\n  super()._render()\n  for child in self._children:\n   child._render()\n  if (node :=self._get_node())is not None :\n   for _ in range(node.childNodes.length -self._children_length):\n    node.childNodes[-1].remove()\n    \n def _get_processed_attrs(self):\n  attrs={name:self._proc_attr(value)for name,value in self._attrs.items()}\n  if \"webcompy-component\"not in self._attrs and self._get_belonging_component():\n   attrs[\"webcompy-cid-\"+self._get_belonging_component()]=\"\"\n  return attrs\n  \n def _proc_attr(self,value:AttrValue):\n  if isinstance(value,ReactiveBase):\n   obj=value.value\n  else :\n   obj=value\n  if isinstance(obj,bool):\n   return \"\"if obj else None\n  elif isinstance(obj,int):\n   return str(obj)\n  else :\n   return str(obj)\n   \n def _remove_element(self,recursive:bool=True ,remove_node:bool=True ):\n  super()._remove_element(recursive,remove_node)\n  if recursive:\n   for child in self._children:\n    child._remove_element(True ,False )\n    \n def _create_child_element(\n self,\n parent:\"ElementWithChildren\",\n node_idx:int |None ,\n child:ElementChildren,\n ):\n  if child is None :\n   return None\n  elif isinstance(child,(str,ReactiveBase)):\n   element=TextElement(child)\n  else :\n   element=child\n  if node_idx is not None :\n   element._node_idx=node_idx\n  element._parent=parent\n  return element\n  \n @property\n def _children_length(self)->int:\n  return sum(child._node_count for child in self._children)\n  \n def _re_index_children(self,recursive:bool=False ):\n  idx=0\n  for c_idx in range(len(self._children)):\n   self._children[c_idx]._node_idx=idx\n   idx +=self._children[c_idx]._node_count\n  if recursive:\n   for child in self._children:\n    if isinstance(child,ElementWithChildren):\n     child._re_index_children(True )\n     \n def _append_child(self,child:ElementChildren):\n  if self._children_length ==0:\n   node_idx=0\n  else :\n   node_idx=self._children[-1]._node_idx+self._children[-1]._node_count\n  child_ele=self._create_child_element(self,node_idx,child)\n  if child_ele is not None :\n   self._children.append(child_ele)\n   \n def _insert_child(self,index:int,child:ElementChildren):\n  child_ele=self._create_child_element(self,None ,child)\n  if child_ele is not None :\n   self._children.insert(index,child_ele)\n   self._re_index_children(False )\n   \n def _pop_child(self,index:int,re_index:bool=False ):\n  self._children[index]._remove_element()\n  del self._children[index]\n  if re_index:\n   self._re_index_children(False )\n   \n def _clear_node_cache(self,recursive:bool=True ):\n  super()._clear_node_cache()\n  if recursive:\n   for child in self._children:\n    child._clear_node_cache(True )\n    \n def _get_belonging_component(self)->str:\n  return self._parent._get_belonging_component()\n  \n def _get_belonging_components(self)->tuple[Any,...]:\n  return self._parent._get_belonging_components()\n  \n def _render_html(\n self,newline:bool=False ,indent:int=2,count:int=0\n )->str:\n  attrs:str=\" \".join(\n  f'{name}=\"{value}\"'if value else name\n  for name,value in self._get_processed_attrs().items()\n  if value is not None\n  )\n  separator=\"\\n\"if newline else \"\"\n  indent_text=(\" \"*indent *count)if newline else \"\"\n  return separator.join(\n  (\n  f'{indent_text}<{self._tag_name}{\" \" + attrs if attrs else \"\"}>',\n  separator.join(\n  child._render_html(newline,indent,count+1)\n  for child in self._children\n  ),\n  f\"{indent_text}</{self._tag_name}>\",\n  )\n  )\n", ["__future__", "typing", "webcompy.elements.typealias._element_property", "webcompy.elements.typealias._html_tag_names", "webcompy.elements.types._abstract", "webcompy.elements.types._text", "webcompy.reactive._base"]], "webcompy.elements.types._dynamic": [".py", "from abc import abstractmethod\nfrom typing import NoReturn\nfrom webcompy.elements.typealias._element_property import ElementChildren\nfrom webcompy.elements.types._base import ElementWithChildren\nfrom webcompy.exception import WebComPyException\n\n\nclass DynamicElement(ElementWithChildren):\n __parent:ElementWithChildren\n \n @property\n def _node_count(self)->int:\n  return sum(child._node_count for child in self._children)\n  \n def _create_child_element(\n self,\n parent:\"ElementWithChildren\",\n node_idx:int |None ,\n child:ElementChildren,\n ):\n  child_element=super()._create_child_element(parent,node_idx,child)\n  if isinstance(child_element,DynamicElement):\n   raise WebComPyException(\"Nested DynamicElement is not allowed.\")\n  return child_element\n  \n def _init_node(self)->NoReturn:\n  raise WebComPyException(\"'DynamicElement' does not have its own node.\")\n  \n def _get_node(self)->NoReturn:\n  raise WebComPyException(\"'DynamicElement' does not have its own node.\")\n  \n def _render_html(\n self,newline:bool=False ,indent:int=2,count:int=0\n )->str:\n  return (\"\\n\"if newline else \"\").join(\n  child._render_html(newline,indent,count)for child in self._children\n  )\n  \n @property\n def _parent(self)->\"ElementWithChildren\":\n  return self.__parent\n  \n @_parent.setter\n def _parent(self,parent:\"ElementWithChildren\"):\n  self.__parent=parent\n  self._on_set_parent()\n  \n @abstractmethod\n def _on_set_parent(self):\n  ...\n", ["abc", "typing", "webcompy.elements.typealias._element_property", "webcompy.elements.types._base", "webcompy.exception"]], "webcompy.elements.types._element": [".py", "from typing import Any,Iterable,cast\nfrom webcompy.reactive._base import ReactiveBase\nfrom webcompy.brython import browser,DOMNode\nfrom webcompy.elements.types._base import ElementWithChildren\nfrom webcompy.elements.typealias._html_tag_names import HtmlTags\nfrom webcompy.elements.typealias._element_property import (\nElementChildren,\nAttrValue,\nEventHandler,\n)\nfrom webcompy.elements.types._refference import DomNodeRef\nfrom webcompy.aio import resolve_async\nfrom webcompy.exception import WebComPyException\n\n\nclass ElementBase(ElementWithChildren):\n _ref:DomNodeRef |None\n \n def _init_node(self)->DOMNode:\n  if browser:\n   prerendered_node=self._get_prerendered_node()\n   if prerendered_node and not hasattr(prerendered_node,\"__webcompy_node__\"):\n    node=prerendered_node\n    self._mounted=True\n    attr_names_to_remove=set(\n    name\n    for name,value in self._get_processed_attrs().items()\n    if value is None and name in node.attrs.keys()\n    )\n    attr_names_to_remove.update(\n    name\n    for name in node.attrs.keys()\n    if name not in self._get_processed_attrs().keys()\n    )\n    for name in attr_names_to_remove:\n     node.removeAttribute(name)\n   else :\n    node:DOMNode=browser.document.createElement(self._tag_name)\n   node.__webcompy_node__=True\n   for name,value in self._get_processed_attrs().items():\n    if value is not None :\n     node.setAttribute(name,value)\n   for name,value in self._attrs.items():\n    if isinstance(value,ReactiveBase):\n     self._set_callback_id(\n     value.on_after_updating(self._generate_attr_updater(name))\n     )\n   for name,callback in self._event_handlers.items():\n    node.bind(name,lambda ev:resolve_async(callback(ev)))\n   if self._ref:\n    self._ref.__init_node__(node)\n   return node\n  else :\n   raise WebComPyException(\"Not in Browser environment.\")\n   \n def _generate_attr_updater(self,name:str):\n  def update_attr(new_value:Any,name:str=name):\n   node=self._get_node()\n   if node is not None :\n    value=self._proc_attr(new_value)\n    if value is None :\n     node.removeAttribute(name)\n    else :\n     node.setAttribute(name,value)\n     \n  return update_attr\n  \n def _init_children(self,children:Iterable[ElementChildren]):\n  for idx in range(self._children_length -1,-1,-1):\n   self._pop_child(idx)\n  for child in children:\n   if child is not None :\n    self._append_child(child)\n    \n def _remove_element(self,recursive:bool=True ,remove_node:bool=True ):\n  if self._ref is not None :\n   self._ref.__reset_node__()\n  super()._remove_element(recursive,remove_node)\n  \n  \nclass Element(ElementBase):\n def __init__(\n self,\n tag_name:HtmlTags,\n attrs:dict[str,AttrValue]={},\n events:dict[str,EventHandler]={},\n ref:DomNodeRef |None =None ,\n children:Iterable[ElementChildren]=[],\n )->None :\n  self._tag_name=cast(HtmlTags,tag_name.lower())\n  self._attrs=attrs if attrs else dict()\n  self._event_handlers=events if events else dict()\n  self._ref=ref\n  self._children=[]\n  super().__init__()\n  self._init_children(children if children else list())\n", ["typing", "webcompy.aio", "webcompy.brython", "webcompy.elements.typealias._element_property", "webcompy.elements.typealias._html_tag_names", "webcompy.elements.types._base", "webcompy.elements.types._refference", "webcompy.exception", "webcompy.reactive._base"]], "webcompy.elements.types._refference": [".py", "from webcompy.brython import DOMNode\nfrom webcompy.exception import WebComPyException\n\n\nclass DomNodeRef:\n _node:DOMNode |None\n \n def __init__(self)->None :\n  self._node=None\n  \n @property\n def node(self)->DOMNode:\n  if self._node is None :\n   raise WebComPyException(\"DomNodeRef is not initialized yet.\")\n  return self._node\n  \n def __init_node__(self,node:DOMNode):\n  self._node=node\n  \n def __reset_node__(self):\n  self._node=None\n", ["webcompy.brython", "webcompy.exception"]], "webcompy.elements.types._repeat": [".py", "from functools import partial\nfrom itertools import chain\nfrom typing import Any,Callable,List,TypeVar\nfrom webcompy.reactive import ReactiveBase,computed\nfrom webcompy.elements.types._text import NewLine\nfrom webcompy.elements.typealias._element_property import ElementChildren\nfrom webcompy.exception import WebComPyException\nfrom webcompy.elements.types._dynamic import DynamicElement\nfrom webcompy.brython import browser\n\n\nT=TypeVar(\"T\")\n\n\nclass RepeatElement(DynamicElement):\n _index_map:list[tuple[Any,tuple[int,int]]]\n \n def __init__(\n self,\n sequence:ReactiveBase[List[T]],\n template:Callable[[T],ElementChildren],\n )->None :\n  self._template=template\n  self._sequence=sequence\n  self._reactive_activated=False\n  \n  if not isinstance(self._sequence,ReactiveBase):\n   raise ValueError(\"Argument 'sequence' must be Reactive Object.\")\n  super().__init__()\n  \n def _on_set_parent(self):\n  if not browser:\n   self._children=self._generate_children()\n   \n def _generate_children(self):\n  return list(\n  filter(\n  None ,\n  map(\n  partial(self._create_child_element,self._parent,None ),\n  map(self._template,self._sequence.value),\n  ),\n  )\n  )\n  \n def _render(self):\n  self._refresh()\n  if not self._reactive_activated:\n   self._reactive_activated=True\n   self._set_callback_id(self._sequence.on_after_updating(self._refresh))\n   \n def _refresh(self,*args:Any):\n  parent_node=self._parent._get_node()\n  if not parent_node:\n   raise WebComPyException(\n   f\"'{self.__class__.__name__}' does not have its parent.\"\n   )\n  for _ in range(len(self._children)):\n   self._children.pop(-1)._remove_element()\n  self._children=self._generate_children()\n  for c_idx,child in enumerate(self._children):\n   child._node_idx=self._node_idx+c_idx\n   child._render()\n  self._parent._re_index_children(False )\n  \n  \nclass MultiLineTextElement(RepeatElement):\n def __init__(self,text:str |ReactiveBase[Any])->None :\n  super().__init__(\n  computed(\n  lambda :list(\n  chain.from_iterable(\n  map(\n  lambda line:(line,NewLine()),\n  str(\n  text.value if isinstance(text,ReactiveBase)else text\n  ).split(\"\\n\"),\n  )\n  )\n  )[:-1]\n  ),\n  lambda s:s,\n  )\n", ["functools", "itertools", "typing", "webcompy.brython", "webcompy.elements.typealias._element_property", "webcompy.elements.types._dynamic", "webcompy.elements.types._text", "webcompy.exception", "webcompy.reactive"]], "webcompy.elements.types._switch": [".py", "from operator import truth\nfrom typing import Any,Callable,List,Tuple,TypeAlias,cast\nfrom webcompy.reactive._base import ReactiveBase\nfrom webcompy.elements.types._abstract import ElementAbstract\nfrom webcompy.elements.typealias._element_property import ElementChildren\nfrom webcompy.exception import WebComPyException\nfrom webcompy.elements.types._dynamic import DynamicElement\nfrom webcompy.brython import browser\n\n\nNodeGenerator:TypeAlias=Callable[[],ElementChildren]\nSwitchCasesReactive:TypeAlias=list[tuple[ReactiveBase[Any],NodeGenerator]]\nSwitchCasesReactiveList:TypeAlias=ReactiveBase[list[tuple[Any,NodeGenerator]]]\nSwitchCases:TypeAlias=SwitchCasesReactive |SwitchCasesReactiveList\n\n\nclass SwitchElement(DynamicElement):\n _rendered_idx:int |None\n \n def __init__(\n self,\n cases:SwitchCases,\n default:NodeGenerator |None ,\n )->None :\n  self._cases=cases\n  self._default=default\n  self._reactive_activated=False\n  self._rendered_idx=None\n  super().__init__()\n  \n def _select_generator(self)->tuple[int,Callable[[],ElementChildren]]:\n  if isinstance(self._cases,ReactiveBase):\n   cases=self._cases.value\n  else :\n   cases=self._cases\n  for idx,(cond,generator)in enumerate(\n  cast(List[Tuple[ReactiveBase[Any]|Any,NodeGenerator]],cases)\n  ):\n   if truth(cond.value if isinstance(cond,ReactiveBase)else cond):\n    return (idx,generator)\n  if self._default:\n   return (-1,self._default)\n  else :\n   return (-1,lambda :None )\n   \n def _generate_children(self,generator:NodeGenerator)->list[ElementAbstract]:\n  ele=self._create_child_element(self._parent,None ,generator())\n  return [ele]if ele is not None else []\n  \n def _render(self):\n  self._refresh()\n  if not self._reactive_activated:\n   self._reactive_activated=True\n   if isinstance(self._cases,ReactiveBase):\n    self._set_callback_id(self._cases.on_after_updating(self._refresh))\n   else :\n    for cond,_ in self._cases:\n     if isinstance(cond,ReactiveBase):\n      self._set_callback_id(cond.on_after_updating(self._refresh))\n      \n def _refresh(self,*args:Any):\n  idx,generator=self._select_generator()\n  if idx ==self._rendered_idx:\n   return\n  parent_node=self._parent._get_node()\n  if not parent_node:\n   raise WebComPyException(\n   f\"'{self.__class__.__name__}' does not have its parent.\"\n   )\n  self._rendered_idx=idx\n  for _ in range(len(self._children)):\n   self._children.pop(-1)._remove_element()\n  self._children=self._generate_children(generator)\n  for c_idx,child in enumerate(self._children):\n   child._node_idx=self._node_idx+c_idx\n   child._render()\n  self._parent._re_index_children(False )\n  \n def _on_set_parent(self):\n  if not browser:\n  \n   def refresh(*args:Any):\n    idx,generator=self._select_generator()\n    self._rendered_idx=idx\n    self._children=self._generate_children(generator)\n    \n   refresh()\n   \n   if not self._reactive_activated:\n    self._reactive_activated=True\n    \n    if isinstance(self._cases,ReactiveBase):\n     self._set_callback_id(self._cases.on_after_updating(refresh))\n    else :\n     for cond,_ in self._cases:\n      if isinstance(cond,ReactiveBase):\n       self._set_callback_id(cond.on_after_updating(refresh))\n", ["operator", "typing", "webcompy.brython", "webcompy.elements.typealias._element_property", "webcompy.elements.types._abstract", "webcompy.elements.types._dynamic", "webcompy.exception", "webcompy.reactive._base"]], "webcompy.elements.types._text": [".py", "from typing import Any,cast\nfrom webcompy.reactive._base import ReactiveBase\nfrom webcompy.brython import browser,DOMNode\nfrom webcompy.elements.types._abstract import ElementAbstract\nfrom webcompy.exception import WebComPyException\n\n\nclass NewLine(ElementAbstract):\n def __init__(self)->None :\n  super().__init__()\n  \n def _init_node(self)->DOMNode:\n  if browser:\n   prerendered_node=self._get_prerendered_node()\n   if prerendered_node and not hasattr(prerendered_node,\"__webcompy_node__\"):\n    node=prerendered_node\n    self._mounted=True\n   else :\n    node=browser.html.BR()\n   node.__webcompy_node__=True\n   return node\n  else :\n   raise WebComPyException(\"Not in Browser environment.\")\n   \n def _render_html(\n self,newline:bool=False ,indent:int=2,count:int=0\n )->str:\n  if newline:\n   return (\" \"*indent *count)+\"<br>\"\n  else :\n   return \"<br>\"\n   \n   \nclass _HTMLTextElement(DOMNode):\n textContent:str\n \n \nclass TextElement(ElementAbstract):\n _node_cache:_HTMLTextElement |None\n \n def __init__(self,text:str |ReactiveBase[Any])->None :\n  self._text=text\n  super().__init__()\n  if isinstance(self._text,ReactiveBase):\n   self._set_callback_id(self._text.on_after_updating(self._update_text))\n   \n def _get_text(self)->str:\n  if isinstance(self._text,ReactiveBase):\n   value=self._text.value\n   text=value if isinstance(value,str)else str(value)\n  else :\n   text=self._text\n  return text\n  \n def _init_node(self)->DOMNode:\n  if browser:\n   prerendered_node=self._get_prerendered_node()\n   if prerendered_node and prerendered_node.nodeName ==\"#text\":\n    prerendered_node.remove()\n   node=browser.document.createTextNode(self._get_text())\n   node.__webcompy_node__=True\n   return node\n  else :\n   raise WebComPyException(\"Not in Browser environment.\")\n   \n def _update_text(self,new_text:str):\n  node=self._get_node()\n  if node:\n   node.textContent=new_text\n   \n def _get_node(self)->_HTMLTextElement:\n  return cast(_HTMLTextElement,super()._get_node())\n  \n def _render_html(\n self,newline:bool=False ,indent:int=2,count:int=0\n )->str:\n  if newline:\n   return (\" \"*indent *count)+self._get_text()\n  else :\n   return self._get_text()\n", ["typing", "webcompy.brython", "webcompy.elements.types._abstract", "webcompy.exception", "webcompy.reactive._base"]], "webcompy.elements.types": [".py", "from webcompy.elements.types._text import NewLine,TextElement\nfrom webcompy.elements.types._abstract import ElementAbstract\nfrom webcompy.elements.types._element import Element\nfrom webcompy.elements.types._repeat import RepeatElement,MultiLineTextElement\nfrom webcompy.elements.types._switch import SwitchElement,SwitchCases\n\n\n__all__=[\n\"ElementAbstract\",\n\"NewLine\",\n\"TextElement\",\n\"MultiLineTextElement\",\n\"Element\",\n\"RepeatElement\",\n\"SwitchElement\",\n\"SwitchCases\",\n]\n", ["webcompy.elements.types._abstract", "webcompy.elements.types._element", "webcompy.elements.types._repeat", "webcompy.elements.types._switch", "webcompy.elements.types._text"], 1], "webcompy.exception": [".py", "class WebComPyException(Exception):\n pass\n \n \n__all__=[\"WebComPyException\"]\n", [], 1], "webcompy.reactive._base": [".py", "from abc import abstractmethod\nfrom functools import wraps\nfrom typing import (\nAny,\nCallable,\nClassVar,\nGeneric,\nParamSpec,\nSet,\nType,\nTypeVar,\ncast,\nfinal,\n)\n\n\nV=TypeVar(\"V\")\nA=ParamSpec(\"A\")\nT=TypeVar(\"T\")\n\n\ndef _instantiate(cls:Type[T])->T:\n return cls()\n \n \n@_instantiate\nclass ReactiveStore:\n __instances:dict[int,\"ReactiveBase[Any]\"]\n __on_before_updating:dict[int,Callable[[Any],Any]]\n __on_after_updating:dict[int,Callable[[Any],Any]]\n __callback_ids:dict[int,Set[int]]\n __latest_callback_id:int\n __dependency:list[\"ReactiveBase[Any]\"]|None\n \n def __init__(self)->None :\n  self.__instances={}\n  self.__on_before_updating={}\n  self.__on_after_updating={}\n  self.__callback_ids={}\n  self.__latest_instance_id=0\n  self.__latest_callback_id=0\n  self.__dependency=None\n  \n def add_reactive_instance(self,reactive:\"ReactiveBase[Any]\"):\n  self.__latest_instance_id +=1\n  reactive.__reactive_id__=self.__latest_instance_id\n  self.__instances[reactive.__reactive_id__]=reactive\n  self.__callback_ids[reactive.__reactive_id__]=set()\n  \n def add_on_after_updating(\n self,reactive:\"ReactiveBase[Any]\",func:Callable[[Any],Any]\n ):\n  self.__latest_callback_id +=1\n  callback_id=self.__latest_callback_id\n  self.__on_after_updating[callback_id]=func\n  self.__callback_ids[reactive.__reactive_id__].add(callback_id)\n  return callback_id\n  \n def add_on_before_updating(\n self,reactive:\"ReactiveBase[Any]\",func:Callable[[Any],Any]\n ):\n  self.__latest_callback_id +=1\n  callback_id=self.__latest_callback_id\n  self.__on_before_updating[callback_id]=func\n  self.__callback_ids[reactive.__reactive_id__].add(callback_id)\n  return callback_id\n  \n def callback_after_updating(self,instance:\"ReactiveBase[Any]\",value:Any):\n  for idx,func in tuple(self.__on_after_updating.items()):\n   if idx in self.__callback_ids[instance.__reactive_id__]:\n    func(value)\n    \n def callback_before_updating(self,instance:\"ReactiveBase[Any]\",value:Any):\n  for idx,func in tuple(self.__on_before_updating.items()):\n   if idx in self.__callback_ids[instance.__reactive_id__]:\n    func(value)\n    \n def resister(self,reactive:\"ReactiveBase[Any]\"):\n  if self.__dependency is not None :\n   self.__dependency.append(reactive)\n   \n def detect_dependency(\n self,func:Callable[[],V]\n )->tuple[V,list[\"ReactiveBase[Any]\"]]:\n  self.__dependency=[]\n  value=func()\n  dependency=self.__dependency\n  self.__dependency=None\n  uniq_ids:set[int]=set()\n  return value,[\n  reactive\n  for reactive in dependency\n  if reactive.__reactive_id__ not in uniq_ids\n  and not uniq_ids.add(reactive.__reactive_id__)\n  ]\n  \n def remove_callback(self,callback_id:int):\n  if callback_id in self.__on_after_updating:\n   del self.__on_after_updating[callback_id]\n  elif callback_id in self.__on_before_updating:\n   del self.__on_before_updating[callback_id]\n  targeted_isntance_id:int |None =None\n  for isntance_id in self.__callback_ids:\n   if callback_id in self.__callback_ids[isntance_id]:\n    targeted_isntance_id=isntance_id\n    break\n  if targeted_isntance_id is not None :\n   self.__callback_ids[targeted_isntance_id].remove(callback_id)\n   \n   \n   \nclass ReactiveBase(Generic[V]):\n _store:ClassVar=ReactiveStore\n _value:V\n __reactive_id__:int\n \n def __init__(self,init_value:V)->None :\n  self._value=init_value\n  self._store.add_reactive_instance(self)\n  \n @property\n @abstractmethod\n def value(self)->V:\n  ...\n  \n @final\n def on_after_updating(self,func:Callable[[V],Any]):\n  return self._store.add_on_after_updating(self,func)\n  \n @final\n def on_before_updating(self,func:Callable[[V],Any]):\n  return self._store.add_on_before_updating(self,func)\n  \n @final\n @staticmethod\n def _change_event(reactive_obj_method:Callable[A,V])->Callable[A,V]:\n  @wraps(reactive_obj_method)\n  def method(*args:A.args,**kwargs:A.kwargs)->V:\n   instance=cast(ReactiveBase[V],args[0])\n   ReactiveBase._store.callback_before_updating(instance,instance._value)\n   ret=reactive_obj_method(*args,**kwargs)\n   ReactiveBase._store.callback_after_updating(instance,ret)\n   return ret\n   \n  return method\n  \n @final\n @staticmethod\n def _get_evnet(reactive_obj_method:Callable[A,V])->Callable[A,V]:\n  @wraps(reactive_obj_method)\n  def method(*args:A.args,**kwargs:A.kwargs)->V:\n   ReactiveBase._store.resister(cast(ReactiveBase[V],args[0]))\n   return reactive_obj_method(*args,**kwargs)\n   \n  return method\n  \n  \nclass Reactive(ReactiveBase[V]):\n @final\n @ReactiveBase._change_event\n def set_value(self,new_value:V)->V:\n  self._value=new_value\n  return self._value\n  \n @final\n @property\n @ReactiveBase._get_evnet\n def value(self)->V:\n  return self._value\n  \n @final\n @value.setter\n def value(self,new_value:V):\n  self.set_value(new_value)\n", ["abc", "functools", "typing"]], "webcompy.reactive._computed": [".py", "from typing import Any,Callable,TypeVar\nfrom webcompy.reactive._base import ReactiveBase\nfrom webcompy.reactive._container import ReactiveReceivable\n\n\nV=TypeVar(\"V\")\n\n\nclass Computed(ReactiveBase[V]):\n _dependencies:list[ReactiveBase[Any]]\n _dependency_callback_ids:list[int]\n \n def __init__(\n self,\n func:Callable[[],V],\n )->None :\n  self.__calc=func\n  init_value,self._dependencies=self._store.detect_dependency(self.__calc)\n  self._dependency_callback_ids=[\n  reactive.on_after_updating(self._compute)for reactive in self._dependencies\n  ]\n  super().__init__(init_value)\n  \n @property\n @ReactiveBase._get_evnet\n def value(self)->V:\n  return self._value\n  \n @ReactiveBase._change_event\n def _compute(self,*_:Any)->V:\n  self._value=self.__calc()\n  return self._value\n  \n  \ndef computed(func:Callable[[],V])->Computed[V]:\n return Computed(func)\n \n \ndef computed_property(method:Callable[[Any],V])->Computed[V]:\n name=method.__name__\n \n def getter(instance:Any)->Computed[V]:\n  if name not in instance.__dict__:\n   _computed=Computed(lambda :method(instance))\n   if isinstance(instance,ReactiveReceivable):\n    instance.__set_reactive_member__(_computed)\n   instance.__dict__[name]=_computed\n  return instance.__dict__[name]\n  \n return property(getter)\n", ["typing", "webcompy.reactive._base", "webcompy.reactive._container"]], "webcompy.reactive._container": [".py", "from typing import Any,cast\nfrom weakref import WeakValueDictionary\nfrom webcompy.reactive._base import ReactiveBase\n\n\nclass ReactiveReceivable:\n __reactive_members__:dict[int,ReactiveBase[Any]]\n \n def __setattr__(self,name:str,value:Any)->None :\n  if isinstance(value,ReactiveBase):\n   self.__set_reactive_member__(cast(ReactiveBase[Any],value))\n  super().__setattr__(name,value)\n  \n def __set_reactive_member__(self,value:ReactiveBase[Any])->None :\n  if not hasattr(self,\"__reactive_members__\"):\n   self.__reactive_members__=cast(\n   dict[int,ReactiveBase[Any]],WeakValueDictionary({})\n   )\n  self.__reactive_members__[id(value)]=value\n  \n def __purge_reactive_members__(self)->None :\n  if hasattr(self,\"__reactive_members__\"):\n   pass\n", ["typing", "weakref", "webcompy.reactive._base"]], "webcompy.reactive._dict": [".py", "from typing import Dict,TypeVar\nfrom webcompy.reactive._base import Reactive,ReactiveBase\n\n\nK=TypeVar(\"K\")\nV=TypeVar(\"V\")\n\n\nclass ReactiveDict(Reactive[Dict[K,V]]):\n def __init__(self,init_value:dict[K,V]={})->None :\n  super().__init__(init_value)\n  \n @ReactiveBase._get_evnet\n def __getitem__(self,key:K):\n  return self._value.__getitem__(key)\n  \n @ReactiveBase._change_event\n def __setitem__(self,key:K,value:V):\n  self._value.__setitem__(key,value)\n  \n @ReactiveBase._get_evnet\n def __len__(self):\n  return len(self._value)\n  \n @ReactiveBase._get_evnet\n def __iter__(self):\n  return iter(self._value)\n  \n def keys(self):\n  return self._value.keys()\n  \n def values(self):\n  return self._value.values()\n  \n def items(self):\n  return self._value.items()\n", ["typing", "webcompy.reactive._base"]], "webcompy.reactive._list": [".py", "from typing import Any,Callable,Iterable,List,TypeVar,cast,overload\nfrom webcompy.reactive._base import Reactive,ReactiveBase\n\n\nV=TypeVar(\"V\")\n\n\nclass ReactiveList(Reactive[List[V]]):\n def __init__(self,init_value:list[V])->None :\n  super().__init__(init_value)\n  \n @ReactiveBase._change_event\n def append(self,value:V):\n  self._value.append(value)\n  \n @ReactiveBase._change_event\n def extend(self,value:Iterable[V]):\n  self._value.extend(value)\n  \n @ReactiveBase._change_event\n def pop(self,index:int |None =None ):\n  return self._value.pop()if index is None else self._value.pop(index)\n  \n @ReactiveBase._change_event\n def insert(self,index:int,value:V):\n  self._value.insert(index,value)\n  \n @ReactiveBase._change_event\n def sort(self,key:Callable[[V],Any]=lambda it:it,reverse:bool=False ):\n  self._value.sort(key=key,reverse=reverse)\n  \n @ReactiveBase._get_evnet\n def index(self,value:V):\n  return self._value.index(value)\n  \n @ReactiveBase._get_evnet\n def count(self,value:V):\n  return self._value.count(value)\n  \n @ReactiveBase._change_event\n def remove(self,value:V):\n  self._value.remove(value)\n  \n @ReactiveBase._change_event\n def clear(self):\n  self._value.clear()\n  \n @ReactiveBase._change_event\n def reverse(self):\n  self._value.reverse()\n  \n @overload\n def __getitem__(self,idx:int)->V:\n  ...\n  \n @overload\n def __getitem__(self,idx:slice)->list[V]:\n  ...\n  \n @ReactiveBase._get_evnet\n def __getitem__(self,idx:int |slice):\n  return self._value.__getitem__(idx)\n  \n @overload\n def __setitem__(self,idx:int,value:V)->None :\n  ...\n  \n @overload\n def __setitem__(self,idx:slice,value:Iterable[V])->None :\n  ...\n  \n @ReactiveBase._change_event\n def __setitem__(self,idx:int |slice,value:V |Iterable[V]):\n  if isinstance(idx,int):\n   self._value.__setitem__(idx,cast(V,value))\n  else :\n   self._value.__setitem__(idx,cast(Iterable[V],value))\n   \n @ReactiveBase._get_evnet\n def __len__(self):\n  return len(self._value)\n  \n @ReactiveBase._get_evnet\n def __iter__(self):\n  return iter(self._value)\n", ["typing", "webcompy.reactive._base"]], "webcompy.reactive._readonly": [".py", "from typing import NoReturn,TypeVar,final\nfrom webcompy.reactive._base import ReactiveBase\nfrom webcompy.reactive._computed import Computed\n\n\nV=TypeVar(\"V\")\n\n\nclass ReadonlyReactive(Computed[V]):\n @final\n def __init__(self)->NoReturn:\n  raise NotImplementedError(\n  \"ReadonlyReactive cannot generate an instance by constructor\"\n  )\n  \n @classmethod\n def __create_instance__(cls,reactive:ReactiveBase[V]):\n  instance=cls.__new__(cls)\n  instance.__set_reactive(reactive)\n  return instance\n  \n def __set_reactive(self,reactive:ReactiveBase[V]):\n  super().__init__(lambda :reactive.value)\n  \n  \ndef readonly(reactive:ReactiveBase[V])->ReadonlyReactive[V]:\n return ReadonlyReactive.__create_instance__(reactive)\n", ["typing", "webcompy.reactive._base", "webcompy.reactive._computed"]], "webcompy.reactive": [".py", "from webcompy.reactive._base import ReactiveBase,Reactive\nfrom webcompy.reactive._computed import Computed,computed,computed_property\nfrom webcompy.reactive._list import ReactiveList\nfrom webcompy.reactive._dict import ReactiveDict\nfrom webcompy.reactive._readonly import readonly\n\n__all__=[\n\"ReactiveBase\",\n\"Reactive\",\n\"ReactiveList\",\n\"ReactiveDict\",\n\"computed\",\n\"computed_property\",\n\"Computed\",\n\"readonly\",\n]\n", ["webcompy.reactive._base", "webcompy.reactive._computed", "webcompy.reactive._dict", "webcompy.reactive._list", "webcompy.reactive._readonly"], 1], "webcompy.router._change_event_hander": [".py", "from typing import Any,Literal\nfrom webcompy.reactive._base import ReactiveBase\nfrom webcompy.brython import browser\n\n\nclass Location(ReactiveBase[str]):\n __mode__:Literal[\"hash\",\"history\"]\n _value:str\n _state:dict[str,Any]|None\n _base_url:str\n \n def __init__(self,mode:Literal[\"hash\",\"history\"],base_url:str)->None :\n  super().__init__(\"\")\n  self._state=None\n  self._base_url=base_url.strip().strip(\"/\")\n  self.set_mode(mode)\n  if browser:\n   if self.__mode__ ==\"hash\"and self._value ==\"\":\n    browser.window.location.replace(\n    f\"/{self._base_url}/#/\"if self._base_url else \"/#/\"\n    )\n   browser.window.addEventListener(\"popstate\",self._refresh_path,False )\n   \n @ReactiveBase._change_event\n def set_mode(self,mode:Literal[\"hash\",\"history\"]):\n  self.__mode__=mode\n  self._refresh_path()\n  \n @property\n @ReactiveBase._get_evnet\n def value(self):\n  return self._value\n  \n @property\n @ReactiveBase._get_evnet\n def state(self):\n  return self._state\n  \n @ReactiveBase._change_event\n def __set_path__(self,path:str,state:dict[str,Any]|None ):\n  self._state=state\n  if self.__mode__ ==\"hash\"and path.startswith(\"#\"):\n   self._value=path[1:]\n  else :\n   self._value=path\n   \n def _refresh_path(self,_:Any=None ):\n  if browser and self.__mode__ ==\"history\":\n   path:str=(\n   browser.window.location.pathname+browser.window.location.search\n   )\n  elif browser and self.__mode__ ==\"hash\":\n   path:str=browser.window.location.hash\n  else :\n   path:str=\"\"\n  if browser:\n   if browser.window.history.state is browser.javascript.NULL:\n    self._state=None\n   else :\n    self._state=browser.window.history.state.to_dict()\n  else :\n   self._state=None\n  self.__set_path__(path,self._state)\n", ["typing", "webcompy.brython", "webcompy.reactive._base"]], "webcompy.router._component": [".py", "from typing import Any,Tuple,Type,TypeAlias,TypeVar\nfrom webcompy.components._abstract import TypedComponentBase\nfrom webcompy.router._context import RouterContext,TypedRouterContext\nfrom webcompy.router._link import TypedRouterLink\n\n\nRoutedComponent:TypeAlias=TypedComponentBase(RouterContext)\n\n\nParamsType=TypeVar(\"ParamsType\")\nQueryParamsType=TypeVar(\"QueryParamsType\")\nPathParamsType=TypeVar(\"PathParamsType\")\n\nTypedRoute:TypeAlias=Tuple[\nType[TypedRouterContext[ParamsType,QueryParamsType,PathParamsType]],\nType[TypedRouterLink[ParamsType,QueryParamsType,PathParamsType]],\n]\n\n\ndef create_typed_route(\n*,\nparams_type:Type[ParamsType]=dict[str,Any],\nquery_type:Type[QueryParamsType]=dict[str,str],\npath_params_type:Type[PathParamsType]=dict[str,str],\n)->TypedRoute[ParamsType,QueryParamsType,PathParamsType]:\n return (\n TypedRouterContext[ParamsType,QueryParamsType,PathParamsType],\n TypedRouterLink[ParamsType,QueryParamsType,PathParamsType],\n )\n", ["typing", "webcompy.components._abstract", "webcompy.router._context", "webcompy.router._link"]], "webcompy.router._context": [".py", "from typing import Any,Generic,NoReturn,TypeAlias,TypeVar,final\n\n\nParamsType=TypeVar(\"ParamsType\")\nQueryParamsType=TypeVar(\"QueryParamsType\")\nPathParamsType=TypeVar(\"PathParamsType\")\n\n\nclass TypedRouterContext(Generic[ParamsType,QueryParamsType,PathParamsType]):\n __path:str\n __state_params:ParamsType\n __query_params:QueryParamsType\n __path_params:PathParamsType\n \n @final\n def __init__(self)->NoReturn:\n  raise NotImplementedError(\n  \"RouterContext cannot generate an instance by constructor\"\n  )\n  \n @classmethod\n def __create_instance__(\n cls,\n *,\n path:str,\n state:ParamsType,\n query_params:QueryParamsType,\n path_params:PathParamsType,\n ):\n  instance=cls.__new__(cls)\n  instance.__path=path\n  instance.__query_params=query_params\n  instance.__path_params=path_params\n  instance.__state_params=state\n  return instance\n  \n @property\n def path(self):\n  return self.__path\n  \n @property\n def path_params(self):\n  return self.__path_params\n  \n @property\n def query(self):\n  return self.__query_params\n  \n @property\n def params(self):\n  return self.__state_params\n  \n def __repr__(self):\n  return (\n  \"RouterContext(\"\n  +\", \".join(\n  f\"{name}={repr(getattr(self, name))}\"\n  for name in (\"path\",\"query\",\"path_params\",\"params\")\n  )\n  +\")\"\n  )\n  \n  \nRouterContext:TypeAlias=TypedRouterContext[\ndict[str,Any],dict[str,str],dict[str,str]\n]\n", ["typing"]], "webcompy.router._link": [".py", "import logging\nfrom typing import (\nAny,\nClassVar,\nDict,\nGeneric,\nList,\nTypeAlias,\nTypeVar,\nUnion,\ncast,\n)\nimport urllib.parse\nfrom webcompy.reactive import ReactiveBase,computed_property\nfrom webcompy.elements.types._element import Element\nfrom webcompy.elements.typealias._element_property import (\nElementChildren,\nAttrValue,\n)\nfrom webcompy.router._router import Router\nfrom webcompy.router._pages import WebComPyRouterException\nfrom webcompy.brython import browser,DOMEvent\nfrom webcompy.utils._serialize import is_json_seriarizable\n\n\nParamsType=TypeVar(\"ParamsType\")\nQueryParamsType=TypeVar(\"QueryParamsType\")\nPathParamsType=TypeVar(\"PathParamsType\")\n\n\nclass TypedRouterLink(Generic[ParamsType,QueryParamsType,PathParamsType],Element):\n _router:ClassVar[Union[Router,None ]]=None\n _base_url:ClassVar[str]\n \n _query:ReactiveBase[dict[str,str]]|None\n _params:ReactiveBase[dict[str,Any]]|None\n _path_params:ReactiveBase[dict[str,str]]|None\n \n def __init__(\n self,\n *,\n to:Union[str,ReactiveBase[str]],\n text:List[Union[str,ReactiveBase[Any]]],\n params:ReactiveBase[ParamsType]|None =None ,\n query:ReactiveBase[QueryParamsType]|None =None ,\n path_params:ReactiveBase[PathParamsType]|None =None ,\n attrs:Dict[str,AttrValue]|None =None ,\n )->None :\n  if TypedRouterLink._router is None :\n   raise WebComPyRouterException(\"'Router' instance is not declarated.\")\n  self._given_attrs=attrs\n  self._to=to\n  self._query=(\n  cast(ReactiveBase[dict[str,str]],query)if query is not None else None\n  )\n  self._params=(\n  cast(ReactiveBase[dict[str,Any]],params)if params is not None else None\n  )\n  self._path_params=(\n  cast(ReactiveBase[dict[str,str]],path_params)\n  if path_params is not None\n  else None\n  )\n  self._text=text\n  super().__init__(\n  \"a\",\n  attrs=self._generate_attrs(),\n  events={\"click\":self._on_click},\n  children=self._generate_children(),\n  )\n  if isinstance(self._to,ReactiveBase):\n   self._to.on_after_updating(self._refresh)\n   \n @staticmethod\n def __set_router__(router:Router |None ):\n  TypedRouterLink._router=router\n  \n def _refresh(self,*_:Any):\n  self._attrs=self._generate_attrs()\n  self._event_handlerst={\"click\":self._on_click}\n  self._init_children(self._generate_children())\n  self._render()\n  \n def _generate_children(self)->list[ElementChildren]:\n  return cast(list[ElementChildren],self._text)\n  \n def _on_click(self,ev:DOMEvent)->None :\n  ev.preventDefault()\n  if not TypedRouterLink._router:\n   raise WebComPyRouterException(\"'Router' instance is not declarated.\")\n  if self._query is not None :\n   if not isinstance(self._query,ReactiveBase)or not isinstance(self._query.value,dict):\n    raise WebComPyRouterException(\n    \"Argument 'query' of RouterLink must be Reactive Object of Dict.\"\n    )\n   if any(not isinstance(k,str)for k in self._query.value.keys()):\n    raise WebComPyRouterException(\n    \"Keys of Argument 'query' of RouterLink must be str.\"\n    )\n   if any(not isinstance(v,str)for v in self._query.value.values()):\n    raise WebComPyRouterException(\n    \"Values of Argument 'query' of RouterLink must be str.\"\n    )\n  if self._params is not None :\n   if not isinstance(self._params,ReactiveBase)or not isinstance(self._params.value,dict):\n    raise WebComPyRouterException(\n    \"Argument 'params' of RouterLink must be Reactive Object of Dict.\"\n    )\n   if any(not isinstance(k,str)for k in self._params.value.keys()):\n    raise WebComPyRouterException(\n    \"Keys of Argument 'params' of RouterLink must be str.\"\n    )\n  if not browser:\n   return\n  href:str=ev.currentTarget.attrs[\"href\"]\n  current_path=(\n  browser.window.location.pathname\n  if TypedRouterLink._router.__mode__ ==\"history\"\n  else browser.window.location.hash\n  )\n  if current_path !=href:\n   if self._params is None :\n    state=None\n    params=None\n   else :\n    params=dict(self._params.value.items())\n    if is_json_seriarizable(self._params.value):\n     state=params\n    else :\n     state=None\n     logging.warn(\n     \"Argument 'params' of RouterLink should be a Reactive Object of json-serializable dict.\"\n     )\n   browser.window.history.pushState(\n   state,\n   browser.javascript.NULL,\n   href,\n   )\n   TypedRouterLink._router.__set_path__(href,params)\n   \n def _generate_attrs(self)->dict[str,AttrValue]:\n  attrs=self._given_attrs if self._given_attrs else {}\n  return {\n  **attrs,\n  \"href\":self._href,\n  \"webcompy-routerlink\":True ,\n  }\n  \n @computed_property\n def _href(self)->str:\n  to=self._to.value if isinstance(self._to,ReactiveBase)else self._to\n  if self._path_params is not None :\n   to=to.format(**self._path_params.value)\n  path_encoded=\"/\".join(map(urllib.parse.quote,to.strip(\"/\").split(\"/\")))\n  to=f\"/{path_encoded}/\"if path_encoded else \"/\"\n  query_encoded=urllib.parse.urlencode(self._query.value if self._query else {})\n  query=\"?\"+query_encoded if query_encoded else \"\"\n  if TypedRouterLink._router:\n   if TypedRouterLink._router.__mode__ ==\"hash\":\n    return \"#\"+to+query\n   elif TypedRouterLink._router.__base_url__:\n    return \"/\"+TypedRouterLink._router.__base_url__+to+query\n   else :\n    return to+query\n  else :\n   return to+query\n   \n   \nRouterLink:TypeAlias=TypedRouterLink[dict[str,Any],dict[str,str],dict[str,str]]\n", ["logging", "typing", "urllib.parse", "webcompy.brython", "webcompy.elements.typealias._element_property", "webcompy.elements.types._element", "webcompy.reactive", "webcompy.router._pages", "webcompy.router._router", "webcompy.utils._serialize"]], "webcompy.router._pages": [".py", "from typing import Any,Dict,List,TypedDict\nfrom webcompy.components import ComponentGenerator\nfrom webcompy.router._context import TypedRouterContext\nfrom webcompy.components import WebComPyComponentException\n\n\nclass WebComPyRouterException(WebComPyComponentException):\n pass\n \n \nclass RouterPageRequired(TypedDict):\n component:ComponentGenerator[TypedRouterContext[Any,Any,Any]]\n path:str\n \n \nclass RouterPage(RouterPageRequired,total=False ):\n path_params:List[Dict[str,str]]\n meta:Any\n", ["typing", "webcompy.components", "webcompy.router._context"]], "webcompy.router._router": [".py", "from functools import partial\nfrom re import compile as re_compile,escape as re_escape\nimport urllib.parse\nfrom typing import (\nAny,\nCallable,\nClassVar,\nList,\nLiteral,\nMatch,\nSequence,\nTuple,\nTypeAlias,\nUnion,\n)\nfrom webcompy.elements.typealias._element_property import ElementChildren\nfrom webcompy.components import ComponentGenerator,WebComPyComponentException\nfrom webcompy.elements.types._switch import NodeGenerator\nfrom webcompy.reactive._computed import computed_property\nfrom webcompy.router._change_event_hander import Location\nfrom webcompy.router._pages import RouterPage\nfrom webcompy.router._context import TypedRouterContext,RouterContext\n\n\nRouteType:TypeAlias=Tuple[\nstr,\nCallable[[str],Match[str]|None ],\nList[str],\nComponentGenerator[RouterContext],\nRouterPage,\n]\n\n_convert_to_regex_pattern=partial(re_compile(r\"\\\\\\{[^\\{\\}/]+\\\\\\}\").sub,r\"([^/]*?)\")\n_get_path_params=re_compile(r\"{([^\\{\\}/]+)}\").findall\n\n\nclass Router:\n _instance:ClassVar[Union[\"Router\",None ]]=None\n \n _location:Location\n __mode__:Literal[\"hash\",\"history\"]\n __routes__:list[RouteType]\n \n def __init__(\n self,\n *pages:RouterPage,\n default:ComponentGenerator[TypedRouterContext[Any,Any,Any]]|None =None ,\n mode:Literal[\"hash\",\"history\"]=\"hash\",\n base_url:str=\"\",\n )->None :\n  if Router._instance:\n   raise WebComPyComponentException(\"Only one instance of 'Router' can exist.\")\n  else :\n   Router._instance=self\n  self.__mode__=mode\n  self.__base_url__=base_url.strip().strip(\"/\")\n  self._base_url_stripper=partial(\n  re_compile(\"^\"+re_escape(\"/\"+self.__base_url__)).sub,\"\"\n  )\n  self._location=Location(self.__mode__,self.__base_url__)\n  self.__routes__=self._generate_routes(pages)\n  self._default=default\n  \n @computed_property\n def __cases__(self):\n  return list(map(self._get_elements_generator,self.__routes__))\n  \n def __default__(self)->ElementChildren:\n  if self._default:\n   current_path,search=self._get_current_path()\n   if current_path ==\"//:404://\":\n    current_path=\"/404.html\"\n   elif self.__mode__ ==\"history\"and self.__base_url__:\n    current_path=self._base_url_stripper(current_path)\n   props=self._generate_router_context(\n   current_path,\n   search,\n   None ,\n   [],\n   )\n   return self._default(props)\n  else :\n   return \"Not Found\"\n   \n def _get_current_path(self):\n  decoded_href=tuple(\n  map(urllib.parse.unquote,self._location.value.split(\"?\",2))\n  )\n  pathname,search=(\n  (decoded_href[0],\"\")if len(decoded_href)==1 else decoded_href\n  )\n  return pathname,search\n  \n def _get_elements_generator(self,args:RouteType)->Tuple[Any,NodeGenerator]:\n  match_targeted_routes,path_param_names,component=args[1:-1]\n  current_path,search=self._get_current_path()\n  if self.__mode__ ==\"history\"and self.__base_url__:\n   current_path=self._base_url_stripper(current_path)\n  match=match_targeted_routes(current_path.strip(\"/\"))\n  if match:\n   props=self._generate_router_context(\n   current_path,\n   search,\n   match,\n   path_param_names,\n   )\n   return (match,lambda :component(props))\n  else :\n   return (match,lambda :None )\n   \n def _generate_router_context(\n self,\n pathname:str,\n search:str,\n match:Match[str]|None ,\n path_param_names:List[str],\n ):\n  query=(\n  {\n  name:value\n  for name,value in (\n  [it[0],\"\"]if len(it)==1 else it\n  for it in (q.split(\"=\",2)for q in search.split(\"&\"))\n  )\n  if name and value\n  }\n  if search\n  else {}\n  )\n  if match:\n   path_params=(\n   dict(zip(path_param_names,match.groups()))if path_param_names else {}\n   )\n  else :\n   path_params={}\n  return TypedRouterContext.__create_instance__(\n  path=pathname,\n  query_params=query,\n  path_params=path_params,\n  state=self._location.state if self._location.state else {},\n  )\n  \n def _generate_route_matcher(self,path:str):\n  return re_compile(_convert_to_regex_pattern(re_escape(path))+\"$\").match\n  \n def _generate_routes(self,pages:Sequence[RouterPage])->list[RouteType]:\n  return [\n  (*path,component,page)\n  for path,component,page in zip(\n  map(\n  lambda path:(\n  path,\n  self._generate_route_matcher(path),\n  _get_path_params(path),\n  ),\n  map(lambda page:page[\"path\"].strip(\"/\"),pages),\n  ),\n  map(lambda page:page[\"component\"],pages),\n  pages,\n  )\n  ]\n  \n def __set_path__(self,path:str,state:dict[str,Any]|None ):\n  self._location.__set_path__(path,state)\n", ["functools", "re", "typing", "urllib.parse", "webcompy.components", "webcompy.elements.typealias._element_property", "webcompy.elements.types._switch", "webcompy.reactive._computed", "webcompy.router._change_event_hander", "webcompy.router._context", "webcompy.router._pages"]], "webcompy.router._view": [".py", "from typing import ClassVar,List,TypedDict,Union\nfrom webcompy.elements.types import Element,SwitchElement\nfrom webcompy.components import ComponentGenerator,WebComPyComponentException\nfrom webcompy.router._router import Router\nfrom webcompy.router._context import RouterContext\n\n\nclass RouterPageRequired(TypedDict):\n path:str\n \n \nclass RouterPage(RouterPageRequired,total=False ):\n component:ComponentGenerator[RouterContext]\n children:List[\"RouterPage\"]\n \n \nclass RouterView(Element):\n _instance:ClassVar[Union[\"RouterView\",None ]]=None\n _router:ClassVar[Union[Router,None ]]=None\n \n def __init__(self)->None :\n  if RouterView._instance:\n   raise WebComPyComponentException(\n   \"Only one instance of 'RouterView' can exist.\"\n   )\n  else :\n   RouterView._instance=self\n  if RouterView._router is None :\n   raise WebComPyComponentException(\"'Router' instance is not declarated.\")\n   \n  super().__init__(\n  tag_name=\"div\",\n  attrs={\"webcompy-routerview\":True },\n  children=[\n  SwitchElement(\n  RouterView._router.__cases__,RouterView._router.__default__\n  )\n  ],\n  )\n  \n @staticmethod\n def __set_router__(router:Router |None ):\n  RouterView._router=router\n", ["typing", "webcompy.components", "webcompy.elements.types", "webcompy.router._context", "webcompy.router._router"]], "webcompy.router": [".py", "from webcompy.router._router import Router\nfrom webcompy.router._context import RouterContext\nfrom webcompy.router._view import RouterView\nfrom webcompy.router._link import RouterLink\nfrom webcompy.router._component import RoutedComponent,create_typed_route\n\n\n__all__=[\n\"Router\",\n\"RouterView\",\n\"RouterLink\",\n\"RouterContext\",\n\"RoutedComponent\",\n\"create_typed_route\",\n]\n", ["webcompy.router._component", "webcompy.router._context", "webcompy.router._link", "webcompy.router._router", "webcompy.router._view"], 1], "webcompy.utils._serialize": [".py", "from typing import Any\n\n\ndef _is_json_seriarizable_value(obj:Any)->bool:\n if isinstance(obj,list):\n  return all(_is_json_seriarizable_value(c)for c in obj)\n elif isinstance(obj,dict):\n  return all(isinstance(k,str)for k in obj.keys())and all(_is_json_seriarizable_value(v)for v in obj.values())\n elif isinstance(obj,(str,int,float,bool))or obj is None :\n  return True\n else :\n  return False\n  \n  \ndef is_json_seriarizable(obj:Any)->bool:\n if isinstance(obj,(list,dict)):\n  return _is_json_seriarizable_value(obj)\n else :\n  return False\n", ["typing"]], "webcompy.utils._text": [".py", "from functools import partial\nfrom itertools import dropwhile\nfrom re import compile as re_compile\nfrom typing import Any\n\n\n_is_blank_line=re_compile(r\"^\\s*$\").match\n_get_head_blanks=re_compile(r\"^\\s+\").match\n\n\ndef strip_multiline_text(text:str):\n lines=list(dropwhile(_is_blank_line,text.split(\"\\n\")))\n if lines:\n  if head_blanks :=_get_head_blanks(lines[0]):\n   return \"\\n\".join(\n   map(\n   partial(re_compile(\"^\"+head_blanks.group()).sub,\"\"),\n   lines,\n   )\n   )\n  else :\n   return \"\\n\".join(lines)\n else :\n  return \"\"\n", ["functools", "itertools", "re", "typing"]], "webcompy.utils": [".py", "from webcompy.utils._serialize import is_json_seriarizable\nfrom webcompy.utils._text import strip_multiline_text\n\n\n__all__=[\n\"is_json_seriarizable\",\n\"strip_multiline_text\",\n]\n", ["webcompy.utils._serialize", "webcompy.utils._text"], 1]}
__BRYTHON__.update_VFS(scripts)
